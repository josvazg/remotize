// Copyright 2010 Jose Luis Vázquez González josvazg@gmail.com
// Use of this source code is governed by a BSD-style

// rii package is the Remote Interface Invocation foundation allowing go 
// programs to use out-of-process services defined by an interface, either
// locally or remotelly without worring (too much or too soon) 
// about the communications. With this package you can remotize local parts of 
// the program or load them dynamically as a plugin.
package rii

import (
	"fmt"
	"reflect"
	"strings"
)

type rmethodspec struct {
	name	string
	f		*reflect.FuncType
	in		[]reflect.Type
	inout	[]reflect.Type
	out		[]reflect.Type
}

// Remotize will create the rpc client/server file needed to use some given 
// interface remotely
func Remotize(iface interface{}) {
	if it,ok:=iface.(*reflect.InterfaceType);ok {
		remotize(it,"")
		return
	}
	t:=reflect.Typeof(iface)
	if pt,ok:=t.(*reflect.PtrType);ok {
		if it,ok2:=pt.Elem().(*reflect.InterfaceType);ok2 {
			remotize(it,"")
			return
		}
	} 
	fmt.Println("Can't remotize",iface,"of non interface type",t)
}

func remotize(it *reflect.InterfaceType, pack string) {
	fmt.Println("Remotizing interface",it)
	nm:=it.NumMethod()
	fmt.Println("Interface exports ",nm,"methods")
	Ifacename:=it.Name()
	ifacename:=strings.ToLower(Ifacename)
	if(pack=="") {
		pack=it.PkgPath()
	}
	gf:=NewGoFile(ifacename+"_rii.go",pack)
	gf.AddLineComment("RII-Autogenerated "+ifacename+` RPC wrapper [DO NOT EDIT!]
Other line
and another line
`)
	gf.DeclType(Ifacename+"Server","struct {\n\ti *"+Ifacename+"\n}")
	gf.DeclType(Ifacename+"Client","struct {\n\tc *rii.Client\n}")
	gf.Debug()
	Debug(`// Sample code with
// some comments
package comments

// comment var
var commentvar int

// comment func
func comment() {
	// nothing
  var cv commentvar
}
`)

/*	nm:=it.NumMethod()
	for i:=0;i<nm;i++ {
		m:=it.Method(i)
		buildMethod(ifacename,i,gf,m)
	}*/
}
/*
func buildMethod(iface string,n int, gf *GoFile,m reflect.Method) {
	fmt.Fprintf(f,"func (st *"+iface+"Stub) "+m.Name+"(")
	nin:=m.Type.NumIn()
	for i:=0;i<nin;i++ {
		if(i>0) {
			fmt.Fprintf(f,",")
		}
		fmt.Fprintf(f,"arg%v %v",i,m.Type.In(i).String())
	}
	fmt.Fprintf(f,") ")
	nout:=m.Type.NumOut()
	if(nout==1) {
		fmt.Fprintf(f,"%v ",m.Type.Out(0).String())
	} else if(nout>1) {
		fmt.Fprintf(f,"(")
		for i:=0;i<nout;i++ {
			if(i>0) {
				fmt.Fprintf(f,",")
			}
			fmt.Fprintf(f,"r%v %v",i,m.Type.Out(i).String())
		}
		fmt.Fprintf(f,")")
	}
	fmt.Fprintf(f,"{\n")
	fmt.Fprintf(f,"\tr,err:=st.invoke(%v",(n+1))
	for i:=0;i<nin;i++ {
		fmt.Fprintf(f,",arg%v",i)
	}
	fmt.Fprintf(f,")\n")
	if(nout==1) {
		fmt.Fprintf(f,"\treturn r[0]\n")
	} else if(nout>1) {	
		for i:=0;i<nout;i++ {
			fmt.Fprintf(f,"\tr%v=r[%v]\n",i,i)
		}
		fmt.Fprintf(f,"\treturn\n")
	}
	fmt.Fprintf(f,"}\n\n")
}

func isInOut(t reflect.Type) bool {
	switch t.Kind() {
		case reflect.Ptr:
			return true
		case reflect.Slice:
			return true
	}
	return false
}*/


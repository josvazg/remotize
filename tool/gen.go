// Copyright 2011 Jose Luis Vázquez González josvazg@gmail.com
// Use of this source code is governed by a BSD-style

// remotize package wraps rpc calls so you don't have to rewrite an interface by
// hand in order to use it remotely. 
package tool

import (
	"bytes"
	"exec"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"os"
	"reflect"
	"github.com/josvazg/remotize"
	"sort"
	"strconv"
	"strings"
)

const RemotizePkg = "github.com/josvazg/remotize"

// remotizer code head and tail & marker
const (
	remotizerHead = `// Autogenerated Remotizer [DO NOT EDIT!]
package main
`
	remotizerTail = `func main() {
	for _,r := range toremotize {
		if e:=tool.Remotize(r); e!=nil {
			panic(e)
		}
	}
}`
)

// The General Spec for a Remotization
type Spec struct {
	packname    string
	isInterface bool
	t           reflect.Type
	imports     map[string]string
	hdr         *bytes.Buffer
	def         *bytes.Buffer
	src         *bytes.Buffer
}

// Remotize remotizes a type, interface or source code specified interface
func Remotize(i interface{}) os.Error {
	var t reflect.Type
	if _, ok := i.(reflect.Type); ok {
		t = i.(reflect.Type)
	} else {
		t = reflect.TypeOf(i)
	}
	if t.Kind() == reflect.Interface {
		return genWrapper(t.Name(), Type2Spec(true, t))
	} else if _, ok := i.(*Spec); ok {
		return genWrapper(t.Name(), i.(*Spec))
	} else if t.NumMethod() > 0 {
		st := t
		for ; st.Kind() == reflect.Ptr; st = st.Elem() {
		}
		return genWrapper(st.Name(), Type2Spec(false, t))
	}
	if t.Kind() == reflect.Ptr {
		return Remotize(t.Elem())
	}
	return os.NewError(fmt.Sprintf("Can't remotize %v!", i))
}

// NewSpec will create an Spec to be remotized
func NewSpec(packname string, isInterface bool, i interface{}) *Spec {
	t := reflect.TypeOf(i)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	return &Spec{packname, isInterface, t, make(map[string]string),
		bytes.NewBufferString(""), bytes.NewBufferString(""), bytes.NewBufferString("")}
}

// Type2Spec Turns a type into a Spec to be remotized
func Type2Spec(isInterface bool, t reflect.Type) *Spec {
	return &Spec{t.PkgPath(), isInterface, t, make(map[string]string),
		bytes.NewBufferString(""), bytes.NewBufferString(""), bytes.NewBufferString("")}
}

// genWrapper generates the wrapper file for a remotized object
func genWrapper(name string, spec *Spec) os.Error {
	f, e := os.Create("remotized" + name + ".go")
	if e != nil {
		return e
	}
	spec.buildInterfaceDef(name)
	spec.buildHeader()
	fmt.Fprintf(f, spec.hdr.String())
	if e := doremotize(spec.t, f, spec.hdr.String()+spec.src.String()); e != nil {
		return e
	}
	f.Close()
	return nil
}

// buildInterfaceDef builds the interface definition and fills the imports field
func (s *Spec) buildInterfaceDef(name string) {
	ifacename := name
	if !s.isInterface {
		ifacename += remotize.Suffix(name)
	}
	fmt.Fprintf(s.def, "type %s interface", ifacename)
	if s.t.NumMethod() > 0 {
		fmt.Fprintf(s.def, " {")
		for i := 0; i < s.t.NumMethod(); i++ {
			m := s.t.Method(i)
			if isExported(m.Name) {
				fmt.Fprintf(s.def, "\n    ")
				s.funcsource(s.def, s.t, &m)
			}
		}
		fmt.Fprintf(s.def, "\n}\n\n")
	}
}

// funcsource will generate the source code for a function declaration (no body)
func (s *Spec) funcsource(w io.Writer, t reflect.Type, m *reflect.Method) {
	start := 0
	if t.Kind() == reflect.Interface {
		fmt.Fprintf(w, m.Name+"(")
	} else if m != nil && m.Name != "" {
		start++
		fmt.Fprintf(w, m.Name+"(")
	} else {
		fmt.Fprintf(w, "func (")
	}
	if m != nil {
		t = m.Type
	}
	for i := start; i < t.NumIn(); i++ {
		s.typesource(w, t.In(i))
		if (i + 1) != t.NumIn() {
			fmt.Fprintf(w, ", ")
		}
	}
	fmt.Fprintf(w, ") ")
	if t.NumOut() > 1 {
		fmt.Fprintf(w, "(")
	}
	for i := 0; i < t.NumOut(); i++ {
		s.typesource(w, t.Out(i))
		if (i + 1) != t.NumOut() {
			fmt.Fprintf(w, ", ")
		}
	}
	if t.NumOut() > 1 {
		fmt.Fprintf(w, ")")
	}
}

// typesource will generate the source code for a type
func (s *Spec) typesource(w io.Writer, t reflect.Type) {
	switch t.Kind() {
	case reflect.Array:
		fmt.Fprintf(w, "["+strconv.Itoa(t.Len())+"]")
		s.typesource(w, t.Elem())
	case reflect.Chan:
		fmt.Fprintf(w, "chan ")
		s.typesource(w, t.Elem())
	case reflect.Func:
		s.funcsource(w, t, nil)
	case reflect.Map:
		fmt.Fprintf(w, "map[")
		s.typesource(w, t.Key())
		fmt.Fprintf(w, "]")
		s.typesource(w, t.Elem())
	case reflect.Ptr:
		fmt.Fprintf(w, "*")
		s.typesource(w, t.Elem())
	case reflect.Slice:
		fmt.Fprintf(w, "[]")
		s.typesource(w, t.Elem())
	case reflect.String:
		fmt.Fprintf(w, "string")
	default:
		s.pack(t)
		fmt.Fprintf(w, t.String())
		return
	}
}

// pack will record the type's package as an import
func (s *Spec) pack(t reflect.Type) {
	packpath := t.PkgPath()
	if packpath != "" {
		alias := t.String()[0 : len(t.String())-len(t.Name())-1]
		s.imports[alias] = packpath
	}
}

// buildHeader will build the header for the source file including package and imports
func (s *Spec) buildHeader() {
	s.hdr = bytes.NewBufferString("// Autogenerated by josvazg/remotize/tool - no need to edit!\n\n")
	fmt.Fprintf(s.hdr, "package %v\n\n", path2pack(s.packname))
	if s.imports == nil {
		s.imports = make(map[string]string)
	}
	s.imports["rpc"] = "rpc"
	s.imports["os"] = "os"
	if s.packname != RemotizePkg {
		s.imports[RemotizePkg] = RemotizePkg
	}
	names := make([]string, 0)
	for _, name := range s.imports {
		names = append(names, name)
	}
	writeImports(s.hdr, names, s.imports, s.packname)
}

func save(filename, contents string) {
	f, e := os.Create(filename)
	if e != nil {
		panic(e)
	}
	f.Write(([]byte)(contents))
	f.Close()
}
/*
func toPackname(t reflect.Type) string {
	if t.Kind() == reflect.Ptr {
		return toPackname(t.Elem())
	}
	path := t.PkgPath()
	parts := strings.Split(path, "/")
	if parts == nil && len(parts) == 1 {
		return path
	}
	return parts[len(parts)-1]
}

func src2ast(src string) *ast.File {
	//fmt.Println(src)
	f, e := parser.ParseFile(token.NewFileSet(), "", src, 0)
	if e != nil {
		panic(e.String() + ":\n" + src)
	}
	return f
}

type remotizeCtx struct {
	pkg string
	w   io.Writer
}

func doremotize(t reflect.Type, w io.Writer, source string) os.Error {
	rctx := remotizeCtx{toPackname(t), w}
	f := src2ast(source)
	//ast.Print(token.NewFileSet(), f)
	rprefix := "remotize."
	if f.Name.Name == RemotizePkg {
		rprefix = ""
	}
	for _, decl := range f.Decls {
		if gendecl, ok := decl.(*ast.GenDecl); ok {
			for _, spec := range gendecl.Specs {
				if ts, ok := spec.(*ast.TypeSpec); ok {
					if it, ok := ts.Type.(*ast.InterfaceType); ok {
						return rctx.remotizeInterface(rprefix, ts.Name.Name, it)
					}
				}
			}
		}
	}
	return nil
}*/

func (s *Spec) buildBody(ifacename string) os.Error {
	fmt.Fprintf(s.src, "// Autoregistry\n")
	fmt.Fprintf(s.src, "func init() {\n")
	fmt.Fprintf(s.src, "    remotize.Register(Remote%s{},\n", ifacename)
	fmt.Fprintf(s.src, "        func(cli *rpc.Client) interface{} "+
		"{\n\t\t\treturn NewRemote%s(cli)\n\t\t},\n", ifacename)
	fmt.Fprintf(s.src, "        %sService{},\n", ifacename)
	fmt.Fprintf(s.src, "        func(srv *rpc.Server, i interface{}) "+
		" interface{} {\n\t\t\treturn New%sService(srv,i.(%s))\n\t\t},\n",
		ifacename, ifacename)
	fmt.Fprintf(s.src, "    )\n")
	fmt.Fprintf(s.src, "}\n\n")
	s.remoteInit(ifacename)
	s.localInit(ifacename)
	for i := 0; i < s.t.NumMethod(); i++ {
		s.wrapMethod(ifacename, s.t.Method(i))
	}
	//fmt.Println(r.w.String())
	return nil
}

func (s *Spec) remoteInit(ifacename string) {
	fmt.Fprintf(s.src, "// Rpc service wrapper for %s\n", ifacename)
	fmt.Fprintf(s.src, "type %sService struct {\n", ifacename)
	fmt.Fprintf(s.src, "    srv %s\n", ifacename)
	fmt.Fprintf(s.src, "}\n\n")
	fmt.Fprintf(s.src, "// Direct %sService constructor\n", ifacename)
	fmt.Fprintf(s.src, "func New%sService(srv *rpc.Server, impl %s) *%sService {\n",
		ifacename, ifacename, ifacename)
	fmt.Fprintf(s.src, "    r:=&%sService{impl}\n", ifacename)
	fmt.Fprintf(s.src, "    srv.Register(r)\n")
	fmt.Fprintf(s.src, "    return r\n")
	fmt.Fprintf(s.src, "}\n\n")
}

func (s *Spec) localInit(ifacename string) {
	fmt.Fprintf(s.src, "// Rpc client for %s\n", ifacename)
	fmt.Fprintf(s.src, "type Remote%s struct {\n", ifacename)
	fmt.Fprintf(s.src, "    cli *rpc.Client\n")
	fmt.Fprintf(s.src, "}\n\n")
	fmt.Fprintf(s.src, "// Direct Remote%s constructor\n", ifacename)
	fmt.Fprintf(s.src, "func NewRemote%s(cli *rpc.Client) *Remote%s {\n",
		ifacename, ifacename)
	fmt.Fprintf(s.src, "    return &Remote%s{cli}\n", ifacename)
	fmt.Fprintf(s.src, "}\n\n")
}

func (s *Spec) wrapMethod(ifacename string, m reflect.Method) {
	fmt.Fprintf(s.src, "// wrapper for: %s\n\n", m.Name)
	argcnt := s.generateStructWrapper(m.Type, "Args", m.Name)
	results, inouts := s.prepareInOuts(m.Type, fun.Results)
	replycnt := s.generateStructWrapper(results, "Reply", m.Name)
	s.generateServerRPCWrapper(fun, ifacename, m.Name, argcnt, replycnt, inouts)
	s.generateClientRPCWrapper(fun, ifacename, m.Name, argcnt, replycnt, inouts)
	fmt.Fprintf(s.src, "\n")
}

func (s *Spec) generateStructWrapper(ft reflect.Type, structname, name string) int {
	fmt.Fprintf(s.src, "type %s_%s struct {\n", structname, name)
	defer fmt.Fprintf(s.src, "}\n\n")
	argn := ft.NumIn()
	for i := 0; i < argn; i++ {
		fmt.Fprintf(s.src, "\tArg%d %s,\n", i, ft.In(i).Name())
	}
	return argn
}

func (s *Spec) prepareInOuts(ft reflect.Type) ([]reflect.Type, []int) {
	args := make([]reflect.Type, 0)
	inouts := make([]int, 0)
	for i := 0; i < ft.NumIn(); i++ {
		args
		if _, ok := field.Type.(*ast.StarExpr); ok {
			args = append(args, field)
			inouts = append(inouts, n)
		}
	}
	if results == nil {
		results = &ast.FieldList{List: args}
	} else {
		results.List = append(results.List, args...)
	}
	return results, inouts
}

func (r *remotizeCtx) printTypeExpr(w io.Writer, e ast.Expr) {
	ty := reflect.TypeOf(e)
	switch t := e.(type) {
	case *ast.StarExpr:
		fmt.Fprintf(w, "*")
		r.printTypeExpr(w, t.X)
	case *ast.Ident:
		fmt.Fprintf(w, t.Name)
	case *ast.ArrayType:
		fmt.Fprintf(w, "[%v]", solveName(t.Len))
		r.printTypeExpr(w, t.Elt)
	case *ast.SelectorExpr:
		buf := bytes.NewBuffer(make([]byte, 0, 256))
		r.printTypeExpr(buf, t.X)
		prefix := buf.String()
		if prefix != r.pkg {
			fmt.Fprintf(w, "%s.", prefix)
		}
		fmt.Fprintf(w, "%s", t.Sel.Name)
	case *ast.FuncType:
		fmt.Fprintf(w, "func(")
		r.printFuncFieldList(w, t.Params)
		fmt.Fprintf(w, ")")
		buf := bytes.NewBuffer(make([]byte, 0, 512))
		nresults := r.printFuncFieldList(buf, t.Results)
		if nresults > 0 {
			results := buf.String()
			if strings.Index(results, " ") != -1 {
				results = "(" + results + ")"
			}
			fmt.Fprintf(w, " %s", results)
		}
	case *ast.MapType:
		fmt.Fprintf(w, "map[")
		r.printTypeExpr(w, t.Key)
		fmt.Fprintf(w, "]")
		r.printTypeExpr(w, t.Value)
	case *ast.InterfaceType:
		fmt.Fprintf(w, "interface{}")
	case *ast.Ellipsis:
		fmt.Fprintf(w, "...")
		r.printTypeExpr(w, t.Elt)
	default:
		fmt.Fprintf(w, "\n[!!] unknown type: %s\n", ty.String())
	}
}

func (r *remotizeCtx) printFuncFieldList(w io.Writer,
f *ast.FieldList) int {
	count := 0
	if f == nil {
		return count
	}
	for i, field := range f.List {
		// names
		if field.Names != nil {
			for j, name := range field.Names {
				fmt.Fprintf(w, "%s", name.Name)
				if j != len(field.Names)-1 {
					fmt.Fprintf(w, ", ")
				}
				count++
			}
			fmt.Fprintf(w, " ")
		} else {
			count++
		}

		// type
		r.printTypeExpr(w, field.Type)

		// ,
		if i != len(f.List)-1 {
			fmt.Fprintf(w, ", ")
		}
	}
	return count
}

// function that is valeing exposed to an RPC API, but calls simple "Server_" one
func (r *remotizeCtx) generateServerRPCWrapper(fun *ast.FuncType,
iface, name string, argcnt, replycnt int, inouts []int) {
	fmt.Fprintf(r.w, "func (r *%sService) %s(args *Args_%s, "+
		"reply *Reply_%s) os.Error {\n", iface, name, name, name)

	fmt.Fprintf(r.w, "\t")
	replies := replycnt - len(inouts)
	for i := 0; i < replies; i++ {
		fmt.Fprintf(r.w, "reply.Arg%d", i)
		if i != replies-1 {
			fmt.Fprintf(r.w, ", ")
		}
	}
	if replies > 0 {
		fmt.Fprintf(r.w, " = ")
	}
	fmt.Fprintf(r.w, "r.srv.%s(", name)
	for i := 0; i < argcnt; i++ {
		fmt.Fprintf(r.w, "args.Arg%d", i)
		if i != argcnt-1 {
			fmt.Fprintf(r.w, ", ")
		}
	}
	fmt.Fprintf(r.w, ")\n")
	for i := replies; i < replycnt; i++ {
		fmt.Fprintf(r.w, "\treply.Arg%d=args.Arg%d\n", i, inouts[i-replies])
	}
	fmt.Fprintf(r.w, "\treturn nil\n}\n\n")
}

func (r *remotizeCtx) generateClientRPCWrapper(fun *ast.FuncType, iface,
name string, argcnt, replycnt int, inouts []int) {
	fmt.Fprintf(r.w, "func (l *Remote%s) %s(", iface, name)
	r.printFuncFieldListUsingArgs(fun.Params)
	fmt.Fprintf(r.w, ")")

	buf := bytes.NewBuffer(make([]byte, 0, 256))
	nresults := r.printFuncFieldList(buf, fun.Results)
	if nresults > 0 {
		results := buf.String()
		if strings.Index(results, " ") != -1 {
			results = "(" + results + ")"
		}
		fmt.Fprintf(r.w, " %s", results)
	}
	fmt.Fprintf(r.w, " {\n")
	fmt.Fprintf(r.w, "\tvar args Args_%s\n", name)
	fmt.Fprintf(r.w, "\tvar reply Reply_%s\n", name)
	for i := 0; i < argcnt; i++ {
		fmt.Fprintf(r.w, "\targs.Arg%d = Arg%d\n", i, i)
	}
	fmt.Fprintf(r.w, "\terr := l.cli.Call(\"%sService.%s\", &args, &reply)\n",
		iface, name)
	fmt.Fprintf(r.w, "\tif err != nil {\n")
	fmt.Fprintf(r.w, "\t\tpanic(err.String())\n\t}\n")

	replies := replycnt - len(inouts)
	for i := replies; i < replycnt; i++ {
		fmt.Fprintf(r.w, "\t*reply.Arg%d=*args.Arg%d\n", i, inouts[i-replies])
	}
	fmt.Fprintf(r.w, "\treturn ")
	for i := 0; i < replycnt; i++ {
		fmt.Fprintf(r.w, "reply.Arg%d", i)
		if i != replycnt-1 {
			fmt.Fprintf(r.w, ", ")
		}
	}
	fmt.Fprintf(r.w, "\n}\n\n")
}

func (r *remotizeCtx) printFuncFieldListUsingArgs(f *ast.FieldList) int {
	count := 0
	if f == nil {
		return count
	}
	for i, field := range f.List {
		// names
		if field.Names != nil {
			for j, _ := range field.Names {
				fmt.Fprintf(r.w, "Arg%d", count)
				if j != len(field.Names)-1 {
					fmt.Fprintf(r.w, ", ")
				}
				count++
			}
			fmt.Fprintf(r.w, " ")
		} else {
			fmt.Fprintf(r.w, "Arg%d ", count)
			count++
		}

		// type
		r.printTypeExpr(r.w, field.Type)

		// ,
		if i != len(f.List)-1 {
			fmt.Fprintf(r.w, ", ")
		}
	}
	return count
}

// suppress will remove the ocurrences of sups strings from s 
// and return the result
func suppress(s string, sups ...string) string {
	for _, sup := range sups {
		s = strings.Replace(s, sup, "", -1)
	}
	return s
}

// fixPack will fix the package name to be present and without alias
/*func (d *Detected) fixPack(name string) string {
	if !strings.Contains(name, ".") {
		return d.currpack + "." + name
	}
	parts := strings.Split(name, ".")
	alias := d.aliases[parts[0]]
	if alias == "" {
		return name
	}
	return alias + "." + parts[1]
}*/

// generateRemotizerCode returns the remotizer source code for a given set of Detected remotizables
func generateRemotizerCode(d *Detected) string {
	src := bytes.NewBuffer(make([]byte, 0))
	fmt.Fprintf(src, remotizerHead)
	genImports(src, d)
	genTypeDefs(src, d)
	fmt.Fprintf(src, "var toremotize = []interface{}{")
	for name, dcl := range d.RDecls {
		fmt.Fprintf(src, "\n\tNewSpec(\"%v\",", d.packname)
		fmt.Fprintf(src, "%v,", dcl.isInterface)
		fmt.Fprintf(src, "new(%v))", ifacename(name))
	}
	for _, s := range d.RTypes {
		fmt.Fprintf(src, "\n\tnew(%v),", s)
	}
	fmt.Fprintf(src, "\n}\n\n")
	fmt.Fprintf(src, remotizerTail)
	return src.String()
}

// genImports adds imports to the remotizer source code from types
func genImports(src io.Writer, d *Detected) {
	imports := []string{"github.com/josvazg/remotize/tool"}
	for _, typename := range d.RTypes {
		packname := strings.SplitN(typename, ".", 2)[0]
		imports = addImport(imports, packname)
	}
	for _, decl := range d.RDecls {
		for packname, _ := range decl.imports {
			imports = addImport(imports, packname)
		}
	}
	writeImports(src, imports, d.aliases, "")
}

func addImport(imports []string, packname string) []string {
	for _, imp := range imports {
		if packname == imp {
			return imports
		}
	}
	return append(imports, packname)
}

// genTypeDefs adds types and interface source code definitions from this packages to the remotizer
func genTypeDefs(src io.Writer, d *Detected) {
	for _, decl := range d.RDecls {
		if decl.Src != nil {
			fmt.Fprintf(src, "\n%s\n", decl.Src)
		}
	}
}

func writeImports(w io.Writer, imports []string, aliases map[string]string, skip string) {
	sort.Strings(imports)
	fmt.Fprintf(w, "import (\n")
	for _, s := range imports {
		v := aliases[s]
		if v == skip || v == "" {
			continue
		}
		if s == v {
			fmt.Fprintf(w, "\t\"%s\"\n", s)
		} else {
			fmt.Fprintf(w, "\t%s \"%s\"\n", s, v)
		}
	}
	fmt.Fprintf(w, ")\n\n")
}

// writeAndFormatSource writes the go source to a file properly formatted
func writeAndFormatSource(filename, source string) os.Error {
	fset := token.NewFileSet()
	f, e := parser.ParseFile(fset, filename+".go", source, parser.ParseComments)
	if e != nil {
		fmt.Println(source)
		return e
	}
	fos, e := os.Create(filename + ".go")
	if e != nil {
		return e
	}
	pcfg := &printer.Config{printer.TabIndent, 2}
	pcfg.Fprint(fos, fset, f)
	fos.Close()
	_, e = os.Stat(filename + ".go")
	return e
}

// build generates a program to remotize the detected interfaces
func buildRemotizer(d *Detected) os.Error {
	src := generateRemotizerCode(d)
	fmt.Println("buildRemotizer:", src, "******* DONE buildRemotizer")
	filename := "_remotizer"
	if e := writeAndFormatSource(filename, src); e != nil {
		return e
	}
	if o, e := RunCmd(Gocompile(), "-I", "_test", filename+".go"); e != nil {
		fmt.Fprintf(os.Stderr, string(o)+"\n")
		return e
	}
	if o, e := RunCmd(Golink(), "-L", "_test", "-o", filename,
		filename+"."+Goext()); e != nil {
		fmt.Fprintf(os.Stderr, string(o)+"\n")
		return e
	}
	if o, e := RunCmd("./" + filename); e != nil {
		fmt.Fprintf(os.Stderr, string(o)+"\n")
		return e
	}
	return nil
}

// runs a command
func RunCmd(cmdargs ...string) ([]byte, os.Error) {
	fmt.Println(cmdargs)
	return exec.Command(cmdargs[0], cmdargs[1:]...).CombinedOutput()
}

// dictionary cache
var dict map[string]string

// go tool execution string
func Goexec(tool string) string {
	if dict == nil {
		dict = make(map[string]string)
		dict["386"] = "8"
		dict["amd64"] = "6"
		dict["arm"] = "5"
		dict["compiler"] = "g"
		dict["linker"] = "l"
	}
	return dict[os.Getenv("GOARCH")] + dict[tool]
}

// Go compiler
func Gocompile() string {
	return Goexec("compiler")
}

// Go linker
func Golink() string {
	return Goexec("linker")
}

// Go architecture extension
func Goext() string {
	return Goexec("")
}


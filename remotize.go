// Copyright 2010 Jose Luis Vázquez González josvazg@gmail.com
// Use of this source code is governed by a BSD-style

// The remotize package wraps rpc calls so you don't have to. 
//
// This root remotize package is the only dependency your programs needs to 
// import within their application. The tool that remotizes you code is on 
// separated packages that won't be linked to your executable unless, of course, 
// you import it especifically for some reason.
// 
package remotize

import (
	"fmt"
	"rpc"
	"reflect"
	"strings"
	"sync"
)

// Remotized Registry
var registry = make(map[string]interface{})

// Registry's lock
var lock sync.RWMutex

// BuildService returns a service wrapper for an interface on a given RpcServer.
//
// Users DON'T need to care about this, as it is done for them by the 
// autogenerated code and will be invoked as appropiate when calling NewService.
type BuildService func(*rpc.Server, interface{}) interface{}

// BuildRemote returns a local reference to a remote interface reachable through
// a given RpcClient.
//
// Users DON'T need to care about this, as it is done for them by the 
// autogenerated code and will be invoked as appropiate when calling NewRemote.
type BuildRemote func(*rpc.Client) interface{}

// Please does nothing. It is just a marker that tells the remotize tool 
// (goremote) that i interface must, "please", be remotized:
//   
//  import remotize
//  ...
//  remotize.Please(new(somepackage.UrlStorer))
//
func Please(i interface{}) {
	// Nothing to do, just a marker
}

// NewService returns a new service wrapper to serve calls to 'ifaceimpl' using 
// 's' RpcServer as transport, so that remote instances will be able to call
// ifaceimple methods.
func NewService(s *rpc.Server, ifaceimpl interface{}) interface{} {

	return NewServiceWith(s, ifaceimpl, ifaceimpl)
}

// NewServiceWith returns a new service wrapper to call 'impl', with interface 
// 'iface' using 's' RpcServer.
func NewServiceWith(s *rpc.Server, iface interface{},
impl interface{}) interface{} {
	p := RegistryFind(searchName("", nameFor(iface)) + "Service")
	if p == nil {
		return nil
	}
	return p.(BuildService)(s, impl)
}

// NewRemote returns a local reference to a remote interface of type iface,
// reachable through c RpcClient.
func NewRemote(c *rpc.Client, iface interface{}) interface{} {
	p := RegistryFind(searchName("Remote", nameFor(iface)))
	if p == nil {
		return nil
	}
	return p.(BuildRemote)(c)
}

// nameFor returns the name of the given underliying type. Pointers are followed
// up to the final referenced type
func nameFor(i interface{}) string {
	t := reflect.TypeOf(i)
	for t.Kind() == reflect.Ptr {
		t = (t).Elem()
	}
	return fmt.Sprintf("%v", t)
}

// searchName will search a prefix and name on the registry
func searchName(prefix, ifacename string) string {
	parts := strings.Split(ifacename, ".")
	if len(parts) == 2 {
		p := ""
		if !strings.HasPrefix(parts[1], prefix) {
			p = prefix
		}
		return parts[0] + "." + p + parts[1] + Suffix(ifacename)
	}
	return ifacename + Suffix(ifacename)
}

// Register will record a local reference to a remote interface 'r', 
// its builder 'br', the corresponding service 's' and its builder, so that they
// can be retrieved later by NewRemote or NewService calls respectively.
//
// Users DON'T need to care about this registration, as it is done by the 
// autogenerated code for them.
func Register(r interface{}, br BuildRemote, s interface{}, bs BuildService) {
	cname := fmt.Sprintf("%v", reflect.TypeOf(r))
	sname := fmt.Sprintf("%v", reflect.TypeOf(s))
	lock.Lock()
	defer lock.Unlock()
	registry[cname] = br
	registry[sname] = bs
}

// DumpRegistry dumps the contents of the registry for debugging purposes 
func DumpRegistry() string {
	var s string
	fmt.Sprintf(s, "%v", registry)
	return s
}

// RegistryFind will find a registered name in the remotize registry
func RegistryFind(name string) interface{} {
	lock.Lock()
	defer lock.Unlock()
	return registry[name]
}

// Suffix will return the proper "r" or "er" or "" ending as an interface for 
// the given 'name'
func Suffix(name string) string {
	s := ""
	if !strings.HasSuffix(name, "er") {
		if EndsWithVowel(name) {
			s = "r"
		} else {
			s = "er"
		}
	}
	return s
}

// EndsWithVowel returns true if str ends with an ASCII vowel (a,e,i,o,u)
func EndsWithVowel(str string) bool {
	vowels := []string{"a", "e", "i", "o", "u"}
	for _, v := range vowels {
		fmt.Println(str,"v=",v)
		if strings.HasSuffix(str, v) {
			return true
		}
	}
	return false
}


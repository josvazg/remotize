// Copyright 2010 Jose Luis Vázquez González josvazg@gmail.com
// Use of this source code is governed by a BSD-style

// remotize package wraps rpc calls so you don't have to rewrite an interface by
// hand in order to use it remotely or out-of-process. 
package remotize

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"os"
	"reflect"
	"rpc"
	"sort"
	"strings"
	"sync"
	"template"
	"time"
)

// UNSET_TIMEOUT
const NoTimeout = 0

// Remotized source code template
const wrapsrc = `// Autogenerated Remotize Interface ${Iface} wrapper [DO NOT EDIT!]
package ${Pack}

import (
${Imports}
)

// Autoregistry
func init() {
	${Prefix}Register(${Iface}Client{},${Iface}Server{})
}

// RPC server exported interface
type ${Iface}RPCs struct {
	s *${Iface}Server
}

// Server wrapper for ${Iface}
type ${Iface}Server struct {
	ServerBase
	Rpcs	*${Iface}RPCs
}

// Bind service
func (s *${Iface}Server) Bind(server *rpc.Server, impl interface{}) {
	s.Base().Bind(server,impl)
	s.Rpcs = &${Iface}RPCs{s}
	server.Register(s.Rpcs)
}

// Local Remote Interface reference
type ${Iface}Remoted struct {
	c *${Iface}Client
}

// Client wrapper for ${Iface}
type ${Iface}Client struct {
	${Prefix}ClientBase
}

// Bind client
func (c *${Iface}Client) Bind(client *rpc.Client) {
	c.Base().Bind(client)
	c.remote = &${Iface}Remoted{c}
}

${Calls}
`

// Error handler interface
type ErrorHandling func(string, os.Error)

// Remotized client type
type ClientBase struct {
	client  *rpc.Client   // rpc transport
	remote  interface{}   // local reference to remote interface
	Handler ErrorHandling // default error handler
	Timeout int64         // default rpc max timeout
}

// Remotized Client using the rpc package as transport
type Client interface {
	Bind(*rpc.Client)    // Binds this client to a rpc.Client
	Base() *ClientBase   // Gets a reference to the base ClientBase
	Remote() interface{} //  Obtain reference to the Remote Interface
}

// Remotized server type
type ServerBase struct {
	server *rpc.Server // rpc server
	impl   interface{} // iface implementation to be invoked
}

// Remotized Server using the rpc package as transport
type Server interface {
	Bind(*rpc.Server, interface{}) // Binds this server to a rpc.Server
	Base() *ServerBase             // Gets a reference to the base Srv
}

// Args
type Args struct {
	A []interface{}
}

// Results
type Results struct {
	R []interface{}
}

// Remotize Timeout
// Includes the timedout call in case the user still need to get it
type Timedout struct {
	os.Error
	Call *rpc.Call
}


// methodInfo for code generation
type methodInfo struct {
	m    methodSpec
	re   bool
	pos  int
	ptrs []int
}

// wrapper infor for code generation
type wrapgen struct {
	Iface   string
	Pack    string
	Prefix  string
	Imports *bytes.Buffer
	Calls   *bytes.Buffer
	imports []string
	methods []methodInfo
}

// Pipe for local invocations, parent/child comms
type Pipe struct {
	in  io.ReadCloser
	out io.WriteCloser
}

// Remotized Registry
var reg = make(map[string]reflect.Type)

// Registry's lock
var lock sync.RWMutex

// Bind associates a ClientBase Client against a rpc.Client
func (c *ClientBase) Bind(client *rpc.Client) {
	c.client = client
}

// Gets a reference to the ClientBase configurable fields on ClientBase itself
func (c *ClientBase) Base() *ClientBase {
	return c
}

// Obtain the local reference to the Remote Interface
func (c *ClientBase) Remote() interface{} {
	return c.remote
}

// Bind associates a ServerBase Server against a rpc.Server and some implementation
func (s *ServerBase) Bind(server *rpc.Server, impl interface{}) {
	s.server = server
	s.impl = impl
}

// Gets a reference to the Base ServerBase 
func (s *ServerBase) Base() *ServerBase {
	return s
}

// Add a remotized type to the registry. The type is Exported since that moment
func Register(c, s interface{}) {
	ct := reflect.TypeOf(c)
	st := reflect.TypeOf(s)
	cname := fmt.Sprintf("%v", ct)
	sname := fmt.Sprintf("%v", st)
	lock.Lock()
	reg[cname] = ct
	reg[sname] = st
	fmt.Println("Registry is now", reg)
	lock.Unlock()
}

// Remove a type from registry. The type is UnExported since that moment
func Unregister(name string) {
	lock.Lock()
	reg[name+"Client"] = nil, false
	reg[name+"Server"] = nil, false
	lock.Unlock()
}

// find from registry
func find(name string) reflect.Type {
	lock.RLock()
	defer lock.RLock()
	return reg[name]
}

// instatiante returns a Ptr instance of the given type, 
// if found in the registry, or nil otherwise
func instantiate(name string) interface{} {
	t := find(name)
	if t == nil {
		return nil
	}
	return reflect.New(t).Interface()
}

// named returns the name of the given underliying type. Pointers are followed
// up to the final referenced type
func nameFor(i interface{}) string {
	t := reflect.TypeOf(i)
	for t.Kind() == reflect.Ptr {
		t = (t).Elem()
	}
	return fmt.Sprintf("%v", t)
}

// NewClient instantiates a client for the given interface, 
// if found on the registry, otherwise nil is returned.
// If pack is NOT empty that package name is used to locate the remotization,
// use it when the remotized code is on a different package from the 
// remotized interface
func NewClient(client *rpc.Client, i interface{}, pack string) Client {
	ifacename := nameFor(i)
	if pack != "" {
		dotpos := strings.LastIndex(ifacename, ".")
		ifacename = pack + "." + ifacename[dotpos:]
	}
	clt := instantiate(ifacename + "Client")
	if clt != nil {
		c := clt.(Client)
		c.Bind(client)
		return c
	}
	return nil
}

// NewServer instantiates a server for the given interface,
// if found on the registry, otherwise nil is returned.
// It also initiates it with the implementation of that interface
func NewServer(server *rpc.Server, i, impl interface{}, pack string) Server {
	if impl == nil {
		impl = i
	}
	ifacename := nameFor(i)
	if pack != "" {
		dotpos := strings.LastIndex(ifacename, ".")
		ifacename = pack + "." + ifacename[dotpos:]
	}
	srv := instantiate(ifacename + "Server")
	if srv != nil {
		s := srv.(Server)
		s.Bind(server, impl)
		return s
	}
	return nil
}

// Call to a remotized method
func Call(c *ClientBase, method string, args ...interface{}) (*Results, os.Error) {
	var r Results
	a := &Args{args}
	var e os.Error
	if c.Timeout == NoTimeout {
		e = c.client.Call(method, a, &r)
	} else {
		e = callTimeout(c, method, a, &r, c.Timeout)
	}
	return &r, e
}

// calltimeout calls with a timeout
func callTimeout(c *ClientBase, method string, args interface{},
reply interface{}, timeout int64) os.Error {
	call := c.client.Go(method, args, reply, nil)
	select {
	case <-call.Done:
		// Call returned
	case <-time.After(timeout):
		msg := fmt.Sprintf("Call timed out %vms at %v()!", timeout, method)
		return &Timedout{os.NewError(msg), call}
	}
	return call.Error
}

// HandleError handles an error
func HandleError(c *ClientBase, funcname string, e os.Error) {
	if c.Handler != nil {
		c.Handler(funcname, e)
	} else {
		errmsg := fmt.Sprintf("Error at %v(): %v", funcname, e)
		panic(errmsg)
	}
}

// Read from the pipe
func (p *Pipe) Read(b []byte) (n int, err os.Error) {
	return p.in.Read(b)
}

// Write to the pipe
func (p *Pipe) Write(b []byte) (n int, err os.Error) {
	return p.out.Write(b)
}

// Close pipe io
func (p *Pipe) Close() os.Error {
	err := p.in.Close()
	if err != nil {
		return err
	}
	return p.out.Close()
}

// Prepare a ReadWriteCloser pipe from a reader and a writer
// This can be passed to NewClient to use RPCs over local pipe streams
func IO(in io.ReadCloser, out io.WriteCloser) *Pipe {
	return &Pipe{in, out}
}

// Autoremotizer template
const autoremotizer = `// Autogenerated Autoremotized [DO NOT EDIT!]
package main

import (
${Imports}
)

var toremotize = []struct {
	iface		interface{}
	position	*token.Position	
}{
${RemotizeList}
}

func main() {
	for _,r := range toremotize {
		remotize.Remotize(r.iface)
		e:=recover()
		if(e!=nil) {
			msg:=fmt.Sprintf("Error remotizing %v: '%v' at %v",
				reflect.Typeof(r.iface),e,r.position)
			panic(msg)
		}
	}
}
`

// remotize item info
type itemInfo struct {
	*token.Position
	spec *ast.TypeSpec
}

// remotize spec
type remotizeSpec struct {
	currpack      string
	importAliases map[string]string
	items         map[string]*itemInfo
	fset          *token.FileSet
	Imports       *bytes.Buffer
	RemotizeList  *bytes.Buffer
}

// supress will remove the ocurrences of sups strings from s 
// and return the result
func suppress(s string, sups ...string) string {
	for _, sup := range sups {
		s = strings.Replace(s, sup, "", -1)
	}
	return s
}

func empty(s string) bool {
	s = strings.Trim(s, " \t")
	return len(s) == 0 || s == "//" || s == "*/"
}

func fixPack(r *remotizeSpec, name string) string {
	if !strings.Contains(name, ".") {
		return r.currpack + "." + name
	}
	parts := strings.Split(name, ".", -1)
	alias := r.importAliases[parts[0]]
	if alias == "" {
		return name
	}
	return alias + "." + parts[1]
}

func parseRemotizeCalls(r *remotizeSpec, decl ast.Decl) {
	call, ok := (interface{})(decl).(*ast.CallExpr)
	if !ok {
		return
	}
	if call.Fun == nil {
		return
	}
	se, ok := call.Fun.(*ast.SelectorExpr)
	name := ""
	if ok {
		id, ok := se.X.(*ast.Ident)
		if !ok || id.Name != "remotize" {
			return
		}
		name = se.Sel.Name
	} else if r.currpack == "remotize" {
		id, ok := call.Fun.(*ast.Ident)
		if !ok {
			return
		}
		name = id.Name
	}
	argpos := -1
	if name == "RemotizePlease" {
		argpos = 0
	}
	if name == "NewServer" || name == "NewClient" {
		argpos = 1
	}
	if len(call.Args) < (argpos+1) || call.Args[argpos] == nil {
		return
	}
	subcall, ok := call.Args[argpos].(*ast.CallExpr)
	if !ok {
		return
	}
	cn, ok := subcall.Fun.(*ast.Ident)
	if !ok || cn.Name != "new" {
		return
	}
	if len(subcall.Args) < 1 || subcall.Args[0] == nil {
		return
	}
	id, ok := subcall.Args[0].(*ast.Ident)
	if !ok {
		return
	}
	pos := r.fset.Position(id.Pos())
	r.items[fixPack(r, id.Name)] = &itemInfo{&pos, nil}
}

func parseComment(r *remotizeSpec, idecl ast.Decl) {
	decl, ok := (interface{})(idecl).(*ast.GenDecl)
	if !ok {
		return
	}
	if decl.Doc == nil {
		return
	}
	if decl.Specs == nil || len(decl.Specs) == 0 {
		return
	}
	tspec, ok := decl.Specs[0].(*ast.TypeSpec)
	if !ok {
		return
	}
	_, ok = tspec.Type.(*ast.InterfaceType)
	if !ok {
		return
	}
	name := fixPack(r, tspec.Name.Name)
	i := len(decl.Doc.List) - 1
	for ; i >= 0 && empty(decl.Doc.List[i].Text); i-- {
	}
	if i >= 0 {
		cmt := decl.Doc.List[i]
		c := string(cmt.Text)
		if strings.Contains(strings.ToLower(c), "(remotize)") {
			if _, ok := r.items[name]; ok {
				return
			}
			pos := r.fset.Position(cmt.Pos())
			r.items[name] = &itemInfo{&pos, tspec}
		}
	}
}

func parseRemotizeDemands(r *remotizeSpec, file *ast.File) {
	for _, decl := range file.Decls {
		parseComment(r, decl)
		parseRemotizeCalls(r, decl)
	}
}

func parseImports(r *remotizeSpec, file *ast.File) {
	r.importAliases = make(map[string]string)
	for _, decl := range file.Decls {
		imp, ok := (interface{})(decl).(*ast.ImportSpec)
		if !ok || imp.Name == nil {
			continue
		}
		path := strings.Trim(imp.Path.Value, "\"")
		if strings.Contains(path, "/") {
			parts := strings.Split(path, "/", -1)
			path = parts[len(parts)-1]
		}
		r.importAliases[path] = imp.Name.Name
	}
}

func parseFile(r *remotizeSpec, file *ast.File) {
	r.currpack = file.Name.Name
	parseImports(r, file)
	parseRemotizeDemands(r, file)
}

func build(r *remotizeSpec) os.Error {
	imports := []string{"go/token", "reflect", "remotize"}
	sort.SortStrings(imports)
	r.Imports = bytes.NewBuffer(make([]byte, 0))
	for _, s := range imports {
		fmt.Fprintf(r.Imports, "\"%v\"\n", s)
	}
	src := bytes.NewBuffer(make([]byte, 0))
	r.RemotizeList = bytes.NewBuffer(make([]byte, 0))
	t := template.New(nil)
	t.SetDelims("${", "}")
	e := t.Parse(autoremotizer)
	if e != nil {
		return e
	}
	for name, pos := range r.items {
		var s string
		if pos.spec == nil {
			s = name
		} else {
			w := bytes.NewBuffer(make([]byte, 0))
			e = printer.Fprint(w, r.fset, pos.spec)
			if e != nil {
				return e
			}
			s = "\x60package " + r.currpack + "\n\n"
			s = s + "type " + w.String() + "\x60"
		}
		fmt.Fprintf(r.RemotizeList, "{%v, &Position{\"%v\",%v,%v,%v}},",
			s, pos.Filename, pos.Offset, pos.Line, pos.Column)
	}
	t.Execute(src, r)
	fset := token.NewFileSet()
	filename := "_autoremotized.go"
	f, e := parser.ParseFile(fset, filename, src, parser.ParseComments)
	if e != nil {
		fmt.Println(src)
		return e
	}
	fos, e := os.Create(filename)
	if e != nil {
		return e
	}
	pcfg := &printer.Config{printer.TabIndent, 2}
	pcfg.Fprint(fos, fset, f)
	fos.Close()
	return nil
}

// Autoremotize will remotize all interfaces in where Remotize is call amongst
// the given list of "files" in their common "path"
func Autoremotize(path string, files []string) (int, os.Error) {
	done := 0
	rs := &remotizeSpec{}
	rs.fset = token.NewFileSet()
	rs.items = make(map[string]*itemInfo)
	for _, f := range files {
		filename := path + "/" + f
		file, e := parser.ParseFile(rs.fset, filename, nil, parser.ParseComments)
		if e != nil {
			return done, e
		}
		parseFile(rs, file)
		//ast.Print(rs.fset, file)
	}
	items := len(rs.items)
	if items == 0 {
		fmt.Println("No interfaces found to remotize")
		return done, nil
	}
	fmt.Printf("Found %v interfaces to remotize:\n", items)
	for name, pos := range rs.items {
		fmt.Println(name, "at", pos)
	}
	e := build(rs)
	if e != nil {
		fmt.Println("Error:", e)
	}
	return done, nil
}

// Remotize will create the rpc client/server file needed to use some given 
// interface remotely
func Remotize(iface interface{}) os.Error {
	src, ok := (iface).(*ast.TypeSpec)
	if ok {
		it, ok := (src.Type).(*ast.InterfaceType)
		if ok {
			return remotize(srcIfaceSpec{src.Name.Name, it}, "")
		}
	}
	if it := reflect.TypeOf(iface); it.Kind() == reflect.Interface {
		return remotize(rtIfaceSpec{it}, "")
	}
	t := reflect.TypeOf(iface)
	if pt := t; pt.Kind() == reflect.Ptr {
		if it := pt.Elem(); it.Kind() == reflect.Interface {
			return remotize(rtIfaceSpec{it}, "")
		}
	}
	msg := fmt.Sprintln("Can't remotize %v of non interface type %v", iface, t)
	return os.NewError(msg)
}

// interface specficication
type ifaceSpec interface {
	Name() string
	PkgPath() string
	NumMethod() int
	MethodSpec(int) methodSpec
}

// runtime interface specification
type rtIfaceSpec struct {
	reflect.Type
}

func (is rtIfaceSpec) MethodSpec(i int) methodSpec {
	return rtMethodSpec{is.Method(i), nil}
}

// source interface specification
type srcIfaceSpec struct {
	name string
	*ast.InterfaceType
}

func (is srcIfaceSpec) Name() string {
	return is.name
}

func (is srcIfaceSpec) PkgPath() string {
	return ""
}

func (is srcIfaceSpec) NumMethod() int {
	return len(is.Methods.List)
}

func (is srcIfaceSpec) MethodSpec(i int) methodSpec {
	m := is.Methods.List[i]
	return srcMethodSpec{m.Names[0].Name, (m.Type).(*ast.FuncType)}
}

// method specification
type methodSpec interface {
	MethodName() string
	NumIn() int
	InName(int) string
	InElem(int) string
	InPkg(int) string
	InIsPtr(int) bool
	NumOut() int
	OutName(int) string
	OutPkg(int) string
	OutIsError(int) bool
}

// runtime method specification
type rtMethodSpec struct {
	reflect.Method
	errorType reflect.Type
}

func (m rtMethodSpec) MethodName() string {
	return m.Name
}

func (m rtMethodSpec) NumIn() int {
	return m.Type.NumIn()
}

func (m rtMethodSpec) InName(i int) string {
	return m.Type.In(i).String()
}

func (m rtMethodSpec) InElem(i int) string {
	return m.Type.In(i).Elem().String()
}

func (m rtMethodSpec) InPkg(i int) string {
	return m.Type.In(i).PkgPath()
}

func (m rtMethodSpec) InIsPtr(i int) bool {
	return m.Type.In(i).Kind() == reflect.Ptr
}

func (m rtMethodSpec) NumOut() int {
	return m.Type.NumOut()
}

func (m rtMethodSpec) OutName(i int) string {
	return m.Type.Out(i).String()
}

func (m rtMethodSpec) OutPkg(i int) string {
	return m.Type.Out(i).PkgPath()
}

func (m rtMethodSpec) OutIsError(i int) bool {
	if m.errorType == nil {
		m.errorType = reflect.TypeOf((*os.Error)(nil)).Elem()
	}
	return m.Type.Out(i) == m.errorType
}


// source method specification
type srcMethodSpec struct {
	name string
	*ast.FuncType
}

func (m srcMethodSpec) MethodName() string {
	return m.name
}

func (m srcMethodSpec) NumIn() int {
	return len(m.Params.List)
}

func solveName(e interface{}) string {
	switch (e).(type) {
	case *ast.Ident:
		return (interface{})(e).(*ast.Ident).Name
	case *ast.StarExpr:
		return "*" + solveName((interface{})(e).(*ast.StarExpr).X)
	case *ast.SelectorExpr:
		se := (interface{})(e).(*ast.SelectorExpr)
		return solveName(se.X) + "." + se.Sel.Name
	}
	return ""
}

func (m srcMethodSpec) InName(i int) string {
	return solveName(m.Params.List[i])
}

func (m srcMethodSpec) InElem(i int) string {
	s := m.InName(i)
	if strings.Index(s, "*") == 0 {
		return s[1:]
	}
	return s
}

func (m srcMethodSpec) InPkg(i int) string {
	s := m.InName(i)
	if i := strings.Index(s, "."); i > 0 {
		return s[0:i]
	}
	return ""
}

func (m srcMethodSpec) InIsPtr(i int) bool {
	s := m.InName(i)
	return strings.Index(s, "*") == 0
}

func (m srcMethodSpec) NumOut() int {
	return len(m.Results.List)
}

func (m srcMethodSpec) OutName(i int) string {
	return solveName(m.Results.List[i])
}

func (m srcMethodSpec) OutPkg(i int) string {
	s := m.OutName(i)
	if i := strings.Index(s, "."); i > 0 {
		return s[0:i]
	}
	return ""
}

func (m srcMethodSpec) OutIsError(i int) bool {
	return m.OutName(i) == "os.Error"
}

// remotize will remotize the interface by generating 
// the proper rpc client/server wrapping
func remotize(is ifaceSpec, pack string) os.Error {
	fmt.Println("Remotizing interface", is.Name())
	if pack == "" {
		pack = is.PkgPath()
	}
	w := newWrapgen(is.Name(), pack)

	nm := is.NumMethod()
	fmt.Println("Interface exports", nm, "methods")
	for i := 0; i < nm; i++ {
		m := is.MethodSpec(i)
		w.addMethod(m)
	}
	return w.genWrapper(is.Name())
}

// newWrapgen creates an interface wrapper generator
func newWrapgen(Ifacename, pack string) *wrapgen {
	w := &wrapgen{Iface: Ifacename,
		Pack:    pack,
		Calls:   bytes.NewBuffer(make([]byte, 0)),
		imports: []string{"os", "rpc"},
	}
	if pack != "remotize" {
		w.imports = append(w.imports, "remotize")
		w.Prefix = "remotize."
	} else {
		w.Prefix = ""
	}
	return w
}

// addMethod wraps another method from the interface
func (w *wrapgen) addMethod(m methodSpec) {
	re, pos := returnsError(m)
	ptrs := inouts(m)
	nin := m.NumIn()
	for i := 0; i < nin; i++ {
		w.addImport(m.InPkg(i))
	}
	nout := m.NumOut()
	for i := 0; i < nout; i++ {
		w.addImport(m.OutPkg(i))
	}
	w.methods = append(w.methods, methodInfo{m, re, pos, ptrs})
	w.clientWrapper()
	w.serverWrapper()
}

// addImport adds an import if needed
func (w *wrapgen) addImport(imp string) {
	if imp == "" { // empty should not be imported
		return
	}
	for _, i := range w.imports {
		if i == imp { // already imported
			return
		}
	}
	w.imports = append(w.imports, imp)
}

// genWrapper generates the final source code for the wrapped interface
func (w *wrapgen) genWrapper(name string) os.Error {
	sort.SortStrings(w.imports)
	w.Imports = bytes.NewBuffer(make([]byte, 0))
	for _, s := range w.imports {
		fmt.Fprintf(w.Imports, "\"%v\"\n", s)
	}
	src := bytes.NewBuffer(make([]byte, 0))
	t := template.New(nil)
	t.SetDelims("${", "}")
	e := t.Parse(wrapsrc)
	if e != nil {
		return e
	}
	t.Execute(src, w)
	fset := token.NewFileSet()
	filename := strings.ToLower(name) + "Remotized.go"
	f, e := parser.ParseFile(fset, filename, src, parser.ParseComments)
	if e != nil {
		return e
	}
	fos, e := os.Create(filename)
	if e != nil {
		return e
	}
	pcfg := &printer.Config{printer.TabIndent, 1}
	pcfg.Fprint(fos, fset, f)
	fos.Close()
	return nil
}

// clientWrapper genrates the whole client wrapping method
func (w *wrapgen) clientWrapper() {
	mi := w.methods[len(w.methods)-1]
	w.methodSignature(mi.m)
	fmt.Fprintf(w.Calls, " {\n")
	w.wrapCall(mi)
	w.clientReturn(mi)
	fmt.Fprintf(w.Calls, "}\n\n")
}

// wrapCall wrapps the call to the server RPC
func (w *wrapgen) wrapCall(mi methodInfo) {
	m := mi.m
	r := "r"
	if m.NumOut()+len(mi.ptrs) == 0 {
		r = "_"
	}
	fmt.Fprintf(w.Calls, "\t%v, e := Call(c.c.Base(),\"%vRPCs.%v\",",
		r, w.Iface, m.MethodName())
	nin := m.NumIn()
	for i := 0; i < nin; i++ {
		if i > 0 {
			fmt.Fprintf(w.Calls, ",")
		}
		fmt.Fprintf(w.Calls, " a%v", (i + 1))
	}
	fmt.Fprintf(w.Calls, ")\n")
}

// methodSignature generates the client wrapper method signature
func (w *wrapgen) methodSignature(m methodSpec) {
	fmt.Fprintf(w.Calls, "// %v.%v Client wrapper\n", w.Iface, m.MethodName())
	fmt.Fprintf(w.Calls, "func (c *%vRemoted) %v(", w.Iface, m.MethodName())
	nin := m.NumIn()
	for i := 0; i < nin; i++ {
		if i > 0 {
			fmt.Fprintf(w.Calls, ",")
		}
		fmt.Fprintf(w.Calls, "a%v %v", (i + 1), m.InName(i))
	}
	fmt.Fprintf(w.Calls, ")")
	nout := m.NumOut()
	if nout > 0 {
		fmt.Fprintf(w.Calls, " ")
		if nout > 1 {
			fmt.Fprintf(w.Calls, "(")
		}
		for i := 0; i < nout; i++ {
			if i > 0 {
				fmt.Fprintf(w.Calls, ",")
			}
			fmt.Fprintf(w.Calls, "%v", m.OutName(i))
		}
		if nout > 1 {
			fmt.Fprintf(w.Calls, ") ")
		}
	}
}

// clientReturn generates the client wrapper return, including error handling
// if needed
func (w *wrapgen) clientReturn(mi methodInfo) {
	m := mi.m
	if !mi.re {
		fmt.Fprintf(w.Calls, "\tif e != nil {\n")
		fmt.Fprintf(w.Calls, "\t\tHandleError(c.c.Base(),\"%v.%v\", e)\n",
			w.Iface, m.MethodName())
		fmt.Fprintf(w.Calls, "\t}\n")
	}
	nout := m.NumOut()
	ninouts := len(mi.ptrs)
	for i := 0; i < ninouts; i++ {
		fmt.Fprintf(w.Calls, "\t*a%v=(r.R[%v]).(%v)\n", mi.ptrs[i]+1, nout+i,
			m.InElem(mi.ptrs[i]))
	}
	if nout > 0 {
		fmt.Fprintf(w.Calls, "\treturn ")
		for i := 0; i < nout; i++ {
			if i != 0 {
				fmt.Fprintf(w.Calls, ", ")
			}
			if i == mi.pos {
				fmt.Fprintf(w.Calls, "e")
			} else {
				fmt.Fprintf(w.Calls, "(r.R[%v]).(%v)", i, m.OutName(i))
			}
		}
		fmt.Fprintf(w.Calls, "\n")
	}
}

// serverWrapper generates the server call wrapper
func (w *wrapgen) serverWrapper() {
	mi := w.methods[len(w.methods)-1]
	m := mi.m
	fmt.Fprintf(w.Calls, "// %v.%v Server wrapper\n", w.Iface, m.MethodName())
	fmt.Fprintf(w.Calls, "func (s *%vRPCs) %v(", w.Iface, m.MethodName())
	fmt.Fprintf(w.Calls, "a *Args, r *Results) os.Error {\n")
	nout := m.NumOut()
	ninouts := len(mi.ptrs)
	if nout+ninouts > 0 {
		fmt.Fprintf(w.Calls, "\tr.R= make([]interface{}, %v)\n", nout+ninouts)
	}
	for i := 0; i < ninouts; i++ {
		fmt.Fprintf(w.Calls, "\ta%v := (a.A[%v]).(%v)\n", mi.ptrs[i]+1, nout+i,
			m.InElem(mi.ptrs[i]))
		fmt.Fprintf(w.Calls, "\tr.R[%v] = &a%v\n", nout+i, mi.ptrs[i]+1)
	}
	fmt.Fprintf(w.Calls, "\t")
	for i := 0; i < nout; i++ {
		if i != 0 {
			fmt.Fprintf(w.Calls, ", ")
		}
		fmt.Fprintf(w.Calls, "r.R[%v]", i)
	}
	if nout > 0 {
		fmt.Fprintf(w.Calls, " = ")
	}
	fmt.Fprintf(w.Calls, "s.s.impl.(%v).%v(", w.Iface, m.MethodName())
	nin := m.NumIn()
	j := 0
	for i := 0; i < nin; i++ {
		if i != 0 {
			fmt.Fprintf(w.Calls, ", ")
		}
		if j < ninouts && i == mi.ptrs[j] {
			fmt.Fprintf(w.Calls, "(r.R[%v]).(%v)", nout+j, m.InName(mi.ptrs[i]))
			j++
		} else {
			fmt.Fprintf(w.Calls, "(a.A[%v]).(%v)", i, m.InName(i))
		}
	}
	fmt.Fprintf(w.Calls, ")\n")
	if mi.re {
		fmt.Fprintf(w.Calls, "\tif r.R[%v] != nil {\n", mi.pos)
		fmt.Fprintf(w.Calls, "\t\treturn (r.R[%v]).(os.Error)\n", mi.pos)
		fmt.Fprintf(w.Calls, "\t}\n")
	}
	fmt.Fprintf(w.Calls, "\treturn nil\n")
	fmt.Fprintf(w.Calls, "}\n\n")
}

// returnsError says whether a method returns an os.Error and where
func returnsError(m methodSpec) (hasError bool, pos int) {
	nout := m.NumOut()
	for i := 0; i < nout; i++ {
		if m.OutIsError(i) {
			return true, i
		}
	}
	return false, -1
}

// inouts returns an array with the positions (starting at o) of input 
// parameters that are pointers. 
// Those pointers should be treated as input/output parameters
func inouts(m methodSpec) []int {
	nin := m.NumIn()
	ptrs := make([]int, 0)
	for i := 0; i < nin; i++ {
		if m.InIsPtr(i) {
			ptrs = append(ptrs, i)
		}
	}
	return ptrs
}


package remotize

import (
	"bytes"
	"exec"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"template"
)

// Remotized source code template
const wrapsrc = `// Autogenerated Remotize Interface ${Iface} wrapper [DO NOT EDIT!]
package ${Pack}

import (
${Imports}
)

// Autoregistry
func init() {
	${Prefix}Register(${Iface}Client{},${Iface}Server{})
}

// RPC server exported interface
type ${Iface}RPCs struct {
	s *${Iface}Server
}

// Server wrapper for ${Iface}
type ${Iface}Server struct {
	ServerBase
	Rpcs	*${Iface}RPCs
}

// Bind service
func (s *${Iface}Server) Bind(server *rpc.Server, impl interface{}) {
	s.Base().Bind(server,impl)
	s.Rpcs = &${Iface}RPCs{s}
	server.Register(s.Rpcs)
}

// Local Remote Interface reference
type ${Iface}Remoted struct {
	c *${Iface}Client
}

// Client wrapper for ${Iface}
type ${Iface}Client struct {
	${Prefix}ClientBase
}

// Bind client
func (c *${Iface}Client) Bind(client *rpc.Client) {
	c.Base().Bind(client)
	c.remote = &${Iface}Remoted{c}
}

${Calls}
`

// Autoremotizer template
const autoremotizer = `// Autogenerated Autoremotizer [DO NOT EDIT!]
package main

import (
${Imports}
)

var toremotize = []remotize.RemotizeSpec{
${RemotizeList}
}

func main() {
	for _,r := range toremotize {
		if e:=remotize.Remotize(r); e!=nil {
			panic(e)
		}
	}
}
`

// methodInfo for code generation
type methodInfo struct {
	m    methodSpec
	re   bool
	pos  int
	ptrs []int
}

// wrapper infor for code generation
type wrapgen struct {
	Iface   string
	Pack    string
	Prefix  string
	Imports *bytes.Buffer
	Calls   *bytes.Buffer
	imports []string
	methods []methodInfo
}

// remotize info
type RemotizeSpec struct {
	Iface interface{}
	Pos   *token.Position
}

/*
	Remotize will create the rpc client/server file needed to use an interface remotely.

	An example invocation will be:
		remotize.Remotize(new(sort.Interface))
*/
func Remotize(iface interface{}) os.Error {
	ri, ok := (iface).(RemotizeSpec)
	if ok {
		if _, ok := ri.Iface.(string); !ok {
			return Remotize(ri.Iface)
		}
		fset := token.NewFileSet()
		file, e := parser.ParseFile(fset, ri.Pos.Filename, nil, parser.ParseComments)
		if e != nil {
			return e
		}
		var tspec *ast.TypeSpec
		ast.Inspect(file, func(n ast.Node) bool {
			if n != nil && fset.Position(n.Pos()).Offset == ri.Pos.Offset {
				tspec = n.(*ast.TypeSpec)
				return false
			}
			return true
		})
		if it, ok := (tspec.Type).(*ast.InterfaceType); ok {
			return remotize(newSrcIfaceSpec(tspec.Name.Name, file.Name.Name, it))
		}
	}
	if it := reflect.TypeOf(iface); it.Kind() == reflect.Interface {
		return remotize(&rtIfaceSpec{it})
	}
	t := reflect.TypeOf(iface)
	if pt := t; pt.Kind() == reflect.Ptr {
		if it := pt.Elem(); it.Kind() == reflect.Interface {
			return remotize(&rtIfaceSpec{it})
		}
	}
	msg := fmt.Sprintf("Can't remotize %v of type %v", iface, t)
	return os.NewError(msg)
}

// build generates a program to remotize the detected interfaces
func build(r *rinfo) os.Error {
	imports := []string{"go/token", "remotize"}
	sort.SortStrings(imports)
	r.Imports = bytes.NewBuffer(make([]byte, 0))
	for _, s := range imports {
		fmt.Fprintf(r.Imports, "\"%v\"\n", s)
	}
	src := bytes.NewBuffer(make([]byte, 0))
	r.RemotizeList = bytes.NewBuffer(make([]byte, 0))
	t := template.New(nil)
	t.SetDelims("${", "}")
	e := t.Parse(autoremotizer)
	if e != nil {
		return e
	}
	for name, pos := range r.items {
		var s string
		if pos.src {
			s = "\"" + name + "\""
		} else {
			s = name
		}
		fmt.Fprintf(r.RemotizeList, "{%v, &token.Position{\"%v\",%v,%v,%v}},",
			s, pos.Filename, pos.Offset, pos.Line, pos.Column)
	}
	t.Execute(src, r)
	fset := token.NewFileSet()
	filename := "_autoremotizer"
	f, e := parser.ParseFile(fset, filename+".go", src, parser.ParseComments)
	if e != nil {
		fmt.Println(src)
		return e
	}
	fos, e := os.Create(filename + ".go")
	if e != nil {
		return e
	}
	pcfg := &printer.Config{printer.TabIndent, 2}
	pcfg.Fprint(fos, fset, f)
	fos.Close()
	_, e = os.Stat("./" + filename + ".go")
	if e != nil {
		return e
	}
	if e = runCmd(gocompile(), "-I", "_test", filename+".go"); e != nil {
		return e
	}
	if e = runCmd(golink(), "-L", "_test", "-o", filename, filename+"."+goext()); e != nil {
		return e
	}
	if e = runCmd("./" + filename); e != nil {
		return e
	}
	return nil
}

// interface specficication
type ifaceSpec interface {
	Name() string              // Name of the interface
	PkgPath() string           // PkgPath is the package path
	NumMethod() int            // NumMethod is the number of methods
	MethodSpec(int) methodSpec // MethodSpec is the methodSpec for method n
}

// method specification
type methodSpec interface {
	MethodName() string
	NumIn() int
	InName(int) string
	InElem(int) string
	InPkg(int) string
	InIsPtr(int) bool
	NumOut() int
	OutName(int) string
	OutPkg(int) string
	OutIsError(int) bool
}

// remotize will remotize the interface by generating 
// the proper rpc client/server wrapping
func remotize(is ifaceSpec) os.Error {
	fmt.Println("Remotizing interface", is.Name())
	w := newWrapgen(is.Name(), is.PkgPath())

	nm := is.NumMethod()
	fmt.Println("Interface exports", nm, "methods")
	for i := 0; i < nm; i++ {
		m := is.MethodSpec(i)
		w.addMethod(m)
	}
	fmt.Println("Generating wrapper...")
	return w.genWrapper(is.Name())
}

// newWrapgen creates an interface wrapper generator
func newWrapgen(Ifacename, pack string) *wrapgen {
	w := &wrapgen{Iface: Ifacename,
		Pack:    pack,
		Calls:   bytes.NewBuffer(make([]byte, 0)),
		imports: []string{"os", "rpc"},
	}
	if pack != "remotize" {
		w.imports = append(w.imports, "remotize")
		w.Prefix = "remotize."
	} else {
		w.Prefix = ""
	}
	return w
}

// addMethod wraps another method from the interface
func (w *wrapgen) addMethod(m methodSpec) {
	re, pos := returnsError(m)
	ptrs := inouts(m)
	nin := m.NumIn()
	for i := 0; i < nin; i++ {
		w.addImport(m.InPkg(i))
	}
	nout := m.NumOut()
	for i := 0; i < nout; i++ {
		w.addImport(m.OutPkg(i))
	}
	w.methods = append(w.methods, methodInfo{m, re, pos, ptrs})
	w.clientWrapper()
	w.serverWrapper()
}

// addImport adds an import if needed
func (w *wrapgen) addImport(imp string) {
	if imp == "" { // empty should not be imported
		return
	}
	for _, i := range w.imports {
		if i == imp { // already imported
			return
		}
	}
	w.imports = append(w.imports, imp)
}

// genWrapper generates the final source code for the wrapped interface
func (w *wrapgen) genWrapper(name string) os.Error {
	sort.SortStrings(w.imports)
	w.Imports = bytes.NewBuffer(make([]byte, 0))
	for _, s := range w.imports {
		fmt.Fprintf(w.Imports, "\"%v\"\n", s)
	}
	src := bytes.NewBuffer(make([]byte, 0))
	t := template.New(nil)
	t.SetDelims("${", "}")
	e := t.Parse(wrapsrc)
	if e != nil {
		fmt.Println("Error parsing source:\n" + wrapsrc)
		return e
	}
	t.Execute(src, w)
	fset := token.NewFileSet()
	filename := strings.ToLower(name) + "Remotized.go"
	f, e := parser.ParseFile(fset, "", src, parser.ParseComments)
	if e != nil {
		fmt.Printf("Error %v parsing file %v src\n", e, filename)
		fos, e := os.Create(filename + ".dump")
		if e != nil {
			fmt.Println("Error creating file:\n" + filename)
			return e
		}
		fmt.Fprintln(fos, src)
		fos.Close()
		return e
	}
	fos, e := os.Create(filename)
	if e != nil {
		fmt.Println("Error creating file:\n" + filename)
		return e
	}
	pcfg := &printer.Config{printer.TabIndent, 1}
	pcfg.Fprint(fos, fset, f)
	fos.Close()
	return nil
}

// clientWrapper genrates the whole client wrapping method
func (w *wrapgen) clientWrapper() {
	mi := w.methods[len(w.methods)-1]
	w.methodSignature(mi.m)
	fmt.Fprintf(w.Calls, " {\n")
	w.wrapCall(mi)
	w.clientReturn(mi)
	fmt.Fprintf(w.Calls, "}\n\n")
}

// wrapCall wrapps the call to the server RPC
func (w *wrapgen) wrapCall(mi methodInfo) {
	m := mi.m
	r := "r"
	if m.NumOut()+len(mi.ptrs) == 0 {
		r = "_"
	}
	fmt.Fprintf(w.Calls, "\t%v, e := Call(c.c.Base(),\"%vRPCs.%v\",",
		r, w.Iface, m.MethodName())
	nin := m.NumIn()
	for i := 0; i < nin; i++ {
		if i > 0 {
			fmt.Fprintf(w.Calls, ",")
		}
		fmt.Fprintf(w.Calls, " a%v", (i + 1))
	}
	fmt.Fprintf(w.Calls, ")\n")
}

// methodSignature generates the client wrapper method signature
func (w *wrapgen) methodSignature(m methodSpec) {
	fmt.Fprintf(w.Calls, "// %v.%v Client wrapper\n", w.Iface, m.MethodName())
	fmt.Fprintf(w.Calls, "func (c *%vRemoted) %v(", w.Iface, m.MethodName())
	nin := m.NumIn()
	for i := 0; i < nin; i++ {
		if i > 0 {
			fmt.Fprintf(w.Calls, ",")
		}
		fmt.Fprintf(w.Calls, "a%v %v", (i + 1), m.InName(i))
	}
	fmt.Fprintf(w.Calls, ")")
	nout := m.NumOut()
	if nout > 0 {
		fmt.Fprintf(w.Calls, " ")
		if nout > 1 {
			fmt.Fprintf(w.Calls, "(")
		}
		for i := 0; i < nout; i++ {
			if i > 0 {
				fmt.Fprintf(w.Calls, ",")
			}
			fmt.Fprintf(w.Calls, "%v", m.OutName(i))
		}
		if nout > 1 {
			fmt.Fprintf(w.Calls, ") ")
		}
	}
}

// clientReturn generates the client wrapper return, including error handling
// if needed
func (w *wrapgen) clientReturn(mi methodInfo) {
	m := mi.m
	if !mi.re {
		fmt.Fprintf(w.Calls, "\tif e != nil {\n")
		fmt.Fprintf(w.Calls, "\t\tHandleError(c.c.Base(),\"%v.%v\", e)\n",
			w.Iface, m.MethodName())
		fmt.Fprintf(w.Calls, "\t}\n")
	}
	nout := m.NumOut()
	ninouts := len(mi.ptrs)
	for i := 0; i < ninouts; i++ {
		fmt.Fprintf(w.Calls, "\t*a%v=(r.R[%v]).(%v)\n", mi.ptrs[i]+1, nout+i,
			m.InElem(mi.ptrs[i]))
	}
	if nout > 0 {
		fmt.Fprintf(w.Calls, "\treturn ")
		for i := 0; i < nout; i++ {
			if i != 0 {
				fmt.Fprintf(w.Calls, ", ")
			}
			if i == mi.pos {
				fmt.Fprintf(w.Calls, "e")
			} else {
				fmt.Fprintf(w.Calls, "(r.R[%v]).(%v)", i, m.OutName(i))
			}
		}
		fmt.Fprintf(w.Calls, "\n")
	}
}

// serverWrapper generates the server call wrapper
func (w *wrapgen) serverWrapper() {
	mi := w.methods[len(w.methods)-1]
	m := mi.m
	fmt.Fprintf(w.Calls, "// %v.%v Server wrapper\n", w.Iface, m.MethodName())
	fmt.Fprintf(w.Calls, "func (s *%vRPCs) %v(", w.Iface, m.MethodName())
	fmt.Fprintf(w.Calls, "a *Args, r *Results) os.Error {\n")
	nout := m.NumOut()
	ninouts := len(mi.ptrs)
	if nout+ninouts > 0 {
		fmt.Fprintf(w.Calls, "\tr.R= make([]interface{}, %v)\n", nout+ninouts)
	}
	for i := 0; i < ninouts; i++ {
		fmt.Fprintf(w.Calls, "\ta%v := (a.A[%v]).(%v)\n", mi.ptrs[i]+1, nout+i,
			m.InElem(mi.ptrs[i]))
		fmt.Fprintf(w.Calls, "\tr.R[%v] = &a%v\n", nout+i, mi.ptrs[i]+1)
	}
	fmt.Fprintf(w.Calls, "\t")
	for i := 0; i < nout; i++ {
		if i != 0 {
			fmt.Fprintf(w.Calls, ", ")
		}
		fmt.Fprintf(w.Calls, "r.R[%v]", i)
	}
	if nout > 0 {
		fmt.Fprintf(w.Calls, " = ")
	}
	fmt.Fprintf(w.Calls, "s.s.impl.(%v).%v(", w.Iface, m.MethodName())
	nin := m.NumIn()
	j := 0
	for i := 0; i < nin; i++ {
		if i != 0 {
			fmt.Fprintf(w.Calls, ", ")
		}
		if j < ninouts && i == mi.ptrs[j] {
			fmt.Fprintf(w.Calls, "(r.R[%v]).(%v)", nout+j, m.InName(mi.ptrs[i]))
			j++
		} else {
			fmt.Fprintf(w.Calls, "(a.A[%v]).(%v)", i, m.InName(i))
		}
	}
	fmt.Fprintf(w.Calls, ")\n")
	if mi.re {
		fmt.Fprintf(w.Calls, "\tif r.R[%v] != nil {\n", mi.pos)
		fmt.Fprintf(w.Calls, "\t\treturn (r.R[%v]).(os.Error)\n", mi.pos)
		fmt.Fprintf(w.Calls, "\t}\n")
	}
	fmt.Fprintf(w.Calls, "\treturn nil\n")
	fmt.Fprintf(w.Calls, "}\n\n")
}

// returnsError says whether a method returns an os.Error and where
func returnsError(m methodSpec) (hasError bool, pos int) {
	nout := m.NumOut()
	for i := 0; i < nout; i++ {
		if m.OutIsError(i) {
			return true, i
		}
	}
	return false, -1
}

// inouts returns an array with the positions (starting at o) of input 
// parameters that are pointers. 
// Those pointers should be treated as input/output parameters
func inouts(m methodSpec) []int {
	nin := m.NumIn()
	ptrs := make([]int, 0)
	for i := 0; i < nin; i++ {
		if m.InIsPtr(i) {
			ptrs = append(ptrs, i)
		}
	}
	return ptrs
}

// runs a command
func runCmd(cmdargs ...string) os.Error {
	fmt.Println(cmdargs)
	c, e := exec.Run(cmdargs[0], cmdargs, os.Environ(), "",
		exec.PassThrough, exec.PassThrough, exec.PassThrough)
	if e != nil {
		return e
	}
	c.Wait(0)
	c.Close()
	return nil
}

// dictionary cache
var dict map[string]string

// go tool execution string
func goexec(tool string) string {
	if dict == nil {
		dict = make(map[string]string)
		dict["386"] = "8"
		dict["amd64"] = "6"
		dict["arm"] = "5"
		dict["compiler"] = "g"
		dict["linker"] = "l"
	}
	return dict[os.Getenv("GOARCH")] + dict[tool]
}

// Go binary directory
func gobin() string {
	return os.Getenv("GOBIN") + filepath.SeparatorString
}

// Go compiler
func gocompile() string {
	return gobin() + goexec("compiler")
}

// Go linker
func golink() string {
	return gobin() + goexec("linker")
}

// Go architecture extension
func goext() string {
	return goexec("")
}


package remotize

import (
	"exec"
	"fmt"
	"io"
	"math"
	"os"
	"path/filepath"
	"rpc"
	"strconv"
	//"strings"
	test "testing"
)

// The interface to remotize
// (Remotize)
//
type Calc interface {
	Add(float64, float64) float64
	AddTo(*float64, float64)
	Subtract(float64, float64) float64
	Multiply(float64, float64) float64
	Divide(float64, float64) (float64, os.Error)
	Pi() float64
	Randomize()
	RandomizeSeed(float64)
}

// The type implementing it
type simplecalc struct{}

func (sc *simplecalc) Add(op1 float64, op2 float64) float64 {
	return op1 + op2
}

func (sc *simplecalc) AddTo(op1 *float64, op2 float64) {
	*op1 = *op1 + op2
}

func (sc *simplecalc) Subtract(op1 float64, op2 float64) float64 {
	return op1 - op2
}

func (sc *simplecalc) Multiply(op1 float64, op2 float64) float64 {
	return op1 * op2
}

func (sc *simplecalc) Divide(op1 float64, op2 float64) (float64, os.Error) {
	if op2 == 0 {
		return 0, os.NewError("Divide " + strconv.Ftoa64(op1, 'f', -1) + " by ZERO!?!")
	}
	return op1 / op2, nil
}

func (sc *simplecalc) Pi() float64 {
	return math.Pi
}

func (sc *simplecalc) Randomize() {
	fmt.Println("Randomized!")
}

func (sc *simplecalc) RandomizeSeed(seed float64) {
	fmt.Println(seed, "randomized!")
}

func TestRemotize(t *test.T) {
	e := Remotize(new(Calc))
	if e != nil {
		fmt.Println(e)
		return
	}
}

func runCmd(cmd string, argv ...string) {
	fmt.Println(cmd, argv)
	c, e := exec.Run(cmd, argv, os.Environ(), "",
		exec.PassThrough, exec.PassThrough, exec.PassThrough)
	if e != nil {
		panic(e)
	}
	c.Wait(0)
	c.Close()
}

var dict map[string]string;

func goexec(tool string)string {
	if dict==nil {
		dict=make(map[string]string)
		dict["386"]="8"
		dict["amd64"]="6"
		dict["arm"]="5"
		dict["compiler"]="g"
		dict["linked"]="l"
	}
	return dict[os.Getenv("GOARCH")]+dict[tool]
}

func TestAutoremotize(t *test.T) {
	fmt.Println("Autoremotize...")
	n, e := Autoremotize(".", []string{"remotize_test.go"})
	if e != nil {
		fmt.Println(e)
		return
	}
	fmt.Println(n, "remotized")
	filename := "_autoremotized"
	_, e = os.Stat("./" + filename + ".go")
	if e != nil {
		fmt.Println(e)
		return
	}
	gopath := os.Getenv("GOBIN") + filepath.SeparatorString
	
	runCmd(gopath+goexec("compiler"), "-I", "_test", filename+".go")
	_, e = os.Stat("./" + filename + ".6")
	if e != nil {
		fmt.Println(e)
		return
	}
	runCmd(gopath+gopath+goexec("linker"), "-L", "_test", filename+".6")
}

func TestRemotized(t *test.T) {
	fmt.Println("Test with autogenerated code")
	server := rpc.NewServer()
	s := NewServer(server, new(Calc), &simplecalc{}, "")
	if s == nil {
		fmt.Println("Autogenerated code not ready yet")
		return
	}
	r1, w1 := io.Pipe()
	r2, w2 := io.Pipe()
	go server.ServeConn(IO(r2, w1))
	ref := NewClient(rpc.NewClient(IO(r1, w2)), new(Calc), "")
	if ref == nil {
		fmt.Println("Autogenerated code client not ready yet")
		return
	}
	c := (ref).Remote().(Calc)
	c.Randomize()
	fmt.Println("Randomize()")
	c.RandomizeSeed(4123423.2314)
	fmt.Println("RandomizeSeed(4123423.2314)")
	fmt.Println("1+2=", c.Add(1, 2))
	// Support for in/out parameters
	val := 1.0
	op := &val
	c.AddTo(op, 2)
	fmt.Println("AddTo 1+2=", *op)
	fmt.Println("1-2=", c.Subtract(1, 2))
	fmt.Println("1123.1234*-2.21432=", c.Multiply(1123.1234, -2.21432))
	d, e := c.Divide(1123.1234, -24.21432)
	fmt.Println("1123.1234/-2.21432=", d, " e=", e)
	fmt.Println("pi=", c.Pi())
}


package remotize

import (
	"fmt"
	"io"
	"math"
	"os"
	"rpc"
	"strconv"
	test "testing"
)

// The type implementing it
// (Remotize)
type Calc struct{}

func (c *Calc) Add(op1 float64, op2 float64) float64 {
	return op1 + op2
}

func (c *Calc) AddTo(op1 *float64, op2 float64) {
	*op1 = *op1 + op2
}

func (c *Calc) Subtract(op1 float64, op2 float64) float64 {
	return op1 - op2
}

func (c *Calc) Multiply(op1 float64, op2 float64) float64 {
	return op1 * op2
}

func (c *Calc) Divide(op1 float64, op2 float64) (float64, os.Error) {
	if op2 == 0 {
		return 0, os.NewError("Divide " + strconv.Ftoa64(op1, 'f', -1) + " by ZERO!?!")
	}
	return op1 / op2, nil
}

func (c *Calc) Pi() float64 {
	return math.Pi
}

func (c *Calc) Randomize() {
	fmt.Println("Randomized!")
}

func (c *Calc) RandomizeSeed(seed float64) {
	fmt.Println(seed, "randomized!")
}

func (c *Calc) Connect(r io.Reader) io.Writer {
	return nil
}

func copy(orig, dest string) os.Error {
	r, e := os.Open(orig)
	if e != nil {
		return e
	}
	w, e := os.Create(dest)
	if e != nil {
		return e
	}
	io.Copy(w, r)
	e = r.Close()
	if e != nil {
		return e
	}
	e = w.Close()
	if e != nil {
		return e
	}
	return nil
}

func TestRemotize(t *test.T) {
	/*fmt.Println("Generating code from NON interface type *simplecalc...")
	e := Remotize(&SimpleCalc{})
	if e != nil {
		fmt.Println(e)
		return
	}
	fmt.Println("Generating code from type new(Calc)...")
	e = Remotize(new(Calc))
	if e != nil {
		fmt.Println(e)
		return
	}
	copy("calcRemotized.go", "calcRemotized.go.rt")
	fmt.Println("Test Remotized Calc with autogenerated code from type...")
	runRemotizedCalc(t)
	fmt.Println("Autoremotize generating code from Calc source...")
	autoremotize(t)
	copy("calcRemotized.go", "calcRemotized.go.src")
	fmt.Println("Test Remotized Calc with autogenerated code from source...")
	runRemotizedCalc(t)*/
	fmt.Println("Testing new remotize code on *Calc...")
	Remotize0("remotize", &Calc{})
	server := rpc.NewServer()
	r := NewRemote(server, new(Calc))
	if r == nil {
		fmt.Println("Autogenerated code not ready yet")
		return
	}
	r1, w1 := io.Pipe()
	r2, w2 := io.Pipe()
	go server.ServeConn(IO(r2, w1))
	l := NewLocal(rpc.NewClient(IO(r1, w2)), new(Calc))
	if l == nil {
		fmt.Println("Autogenerated code client not ready yet")
		return
	}
	c := (l).(Calcer)
	c.Randomize()
	fmt.Println("Randomize()")
	c.RandomizeSeed(4123423.2314)
	fmt.Println("RandomizeSeed(4123423.2314)")
	fmt.Println("1+2=", c.Add(1, 2))
	// Support for in/out parameters
	val := 1.0
	op := &val
	c.AddTo(op, 2)
	fmt.Println("AddTo 1+2=", *op)
	fmt.Println("1-2=", c.Subtract(1, 2))
	fmt.Println("1123.1234*-2.21432=", c.Multiply(1123.1234, -2.21432))
	d, e := c.Divide(1123.1234, -24.21432)
	fmt.Println("1123.1234/-2.21432=", d, " e=", e)
	fmt.Println("pi=", c.Pi())
}

func autoremotize(t *test.T) {
	n, e := Autoremotize(".", []string{"remotize_test.go"})
	if e != nil {
		fmt.Println(e)
		return
	}
	fmt.Println(n, "remotized")
}

func runRemotizedCalc(t *test.T) {
	// will invoke TestRemotizedCalc test explicitly
}

func TestRemotizedCalc(t *test.T) {
	/*
		server := rpc.NewServer()
		s := NewServer(server, new(Calc), &simplecalc{}, "")
		if s == nil {
			fmt.Println("Autogenerated code not ready yet")
			return
		}
		r1, w1 := io.Pipe()
		r2, w2 := io.Pipe()
		go server.ServeConn(IO(r2, w1))
		ref := NewClient(rpc.NewClient(IO(r1, w2)), new(Calc), "")
		if ref == nil {
			fmt.Println("Autogenerated code client not ready yet")
			return
		}
		c := (ref).Remote().(Calc)
		c.Randomize()
		fmt.Println("Randomize()")
		c.RandomizeSeed(4123423.2314)
		fmt.Println("RandomizeSeed(4123423.2314)")
		fmt.Println("1+2=", c.Add(1, 2))
		// Support for in/out parameters
		val := 1.0
		op := &val
		c.AddTo(op, 2)
		fmt.Println("AddTo 1+2=", *op)
		fmt.Println("1-2=", c.Subtract(1, 2))
		fmt.Println("1123.1234*-2.21432=", c.Multiply(1123.1234, -2.21432))
		d, e := c.Divide(1123.1234, -24.21432)
		fmt.Println("1123.1234/-2.21432=", d, " e=", e)
		fmt.Println("pi=", c.Pi())*/
}


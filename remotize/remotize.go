// Copyright 2010 Jose Luis Vázquez González josvazg@gmail.com
// Use of this source code is governed by a BSD-style

// remotize package wraps rpc calls so you don't have to rewrite an interface by
// hand in order to use it remotely or out-of-process. 
package remotize

import (
	"bytes"
	"fmt"
	"http"
	"io"
	"net"
	"os"
	"reflect"
	"rpc"
	"template"
	"time"
)

// Error handler interface
type ErrorHandling func(string, os.Error)

// RemotizeClient using the rpc package as transport
type Client struct {
	client  *rpc.Client   // rpc transport
	handler ErrorHandling // default error handler
	timeout int64         // default rpc max timeout
}

// Args
type Args struct {
	A []interface{}
}

// Results
type Results struct {
	R []interface{}
}

// Remotize Timeout
// Includes the timedout call in case the user still need to get it
type Timeout struct {
	os.Error
	TimeoutCall *rpc.Call
}

// UNSET_TIMEOUT
const NoTimeout = 0

// Default Remotize error handling routine for all remote interfaces
var DefaultErrorHandling ErrorHandling

// Create a new Remotized Client
func NewClient(rwc io.ReadWriteCloser) *Client {
	return &Client{rpc.NewClient(rwc), nil, NoTimeout}
}

// Remotize Call to a method
// No need to synchronize the transport here, rpc does it already
func (c *Client) Call(method string, args ...interface{}) (*Results, os.Error) {
	var r Results
	a := &Args{args}
	var e os.Error
	if c.timeout == NoTimeout {
		e = c.client.Call(method, a, &r)
	} else {
		e = c.callTimeout(method, a, &r, c.timeout)
	}
	return &r, e
}

// Call with timeout
func (c *Client) callTimeout(method string, args interface{},
reply interface{}, timeout int64) os.Error {
	call := c.client.Go(method, args, reply, nil)
	select {
	case <-call.Done:
		// Call returned
	case <-time.After(timeout):
		msg := fmt.Sprintf("Call timed out %vms at %v()!", timeout, method)
		return &Timeout{os.NewError(msg), call}
	}
	return call.Error
}

// Handle an error
func (c *Client) HandleError(funcname string, e os.Error) {
	if c.handler != nil {
		c.handler(funcname, e)
	} else if DefaultErrorHandling != nil {
		DefaultErrorHandling(funcname, e)
	} else {
		errmsg := fmt.Sprintf("Error at %v(): %v", funcname, e)
		panic(errmsg)
	}
}

// Set remote interface error handler
func (c *Client) ErrorHandler(f ErrorHandling) {
	c.handler = f
}

// Set remote interface default timeout
func (c *Client) Timeout(timeout int64) {
	c.timeout = timeout
}

// Pipe for local invocations, parent/child comms
type pipe struct {
	in  io.ReadCloser
	out io.WriteCloser
}

// Read from the pipe
func (p *pipe) Read(b []byte) (n int, err os.Error) {
	return p.in.Read(b)
}

// Write to the pipe
func (p *pipe) Write(b []byte) (n int, err os.Error) {
	return p.out.Write(b)
}

// Close pipe io
func (p *pipe) Close() os.Error {
	err := p.in.Close()
	if err != nil {
		return err
	}
	return p.out.Close()
}

// Prepare a ReadWriteCloser pipe from a reader and a writer
// This can be passed to NewClient to use RPCs over local pipe streams
func IO(in io.ReadCloser, out io.WriteCloser) *pipe {
	return &pipe{in, out}
}

// Remotized Server using the rpc package as transport
type Server struct {
	server *rpc.Server // rpc server
	Iface  interface{} // iface to be invoked
}

// Create a new Remotized Server on a local io pipe
func NewServer(iface interface{}) *Server {
	s := &Server{rpc.NewServer(), iface}
	s.server.Register(iface)
	return s
}

// Do serve on a (local) pipe
func (s *Server) ServePipe(rwc io.ReadWriteCloser) {
	go s.server.ServeConn(rwc)
}

// Do serve on a network listener
func (s *Server) Serve(l net.Listener) {
	http.Serve(l, nil)
}


const wrapsrc = `// Autogenerated Remotize Interface [{Iface}] wrapper [DO NOT EDIT!]
package [{Pack}]

// Server wrapper for [{Iface}]
type [{Iface}]Server {
	[{Iface}]
}

// Client wrapper for [{Iface}]
type [{Iface}]Client {
	c	*rpc.Client
}

[{Calls}]
`

type wrapper struct {
	Iface string
	Pack  string
	Calls *bytes.Buffer
}

// Remotize will create the rpc client/server file needed to use some given 
// interface remotely
func Remotize(iface interface{}) {
	if it, ok := iface.(*reflect.InterfaceType); ok {
		remotize(it, "")
		return
	}
	t := reflect.Typeof(iface)
	if pt, ok := t.(*reflect.PtrType); ok {
		if it, ok2 := pt.Elem().(*reflect.InterfaceType); ok2 {
			remotize(it, "")
			return
		}
	}
	fmt.Println("Can't remotize", iface, "of non interface type", t)
}

func remotize(it *reflect.InterfaceType, pack string) {
	fmt.Println("Remotizing interface", it)
	Ifacename := it.Name()
	if pack == "" {
		pack = it.PkgPath()
	}
	t := template.New(nil)
	t.SetDelims("[{", "}]")
	e := t.Parse(wrapsrc)
	if e != nil {
		fmt.Println("Error:", e)
	}
	data := &wrapper{Ifacename, pack, bytes.NewBuffer(make([]byte, 0))}
	nm := it.NumMethod()
	fmt.Println("Interface exports ", nm, "methods")
	for i := 0; i < nm; i++ {
		m := it.Method(i)
		addMethodPair(data, i, m)
	}
	t.Execute(os.Stdout, data)

	/*Debug(`// Sample code with
	// some comments
	package comments

	// comment var
	var commentvar int

	// comment func
	func comment() {
		// nothing
	  var cv commentvar
	}
	`)*/

	/*	nm:=it.NumMethod()
		for i:=0;i<nm;i++ {
			m:=it.Method(i)
			buildMethod(ifacename,i,gf,m)
		}*/
}

func addMethodPair(w *wrapper, n int, m reflect.Method) {
	fmt.Fprintf(w.Calls, "func (c *Client%v) %v(", w.Iface, m.Name)
	nin := m.Type.NumIn()
	for i := 0; i < nin; i++ {
		if i > 0 {
			fmt.Fprintf(w.Calls, ",")
		}
		fmt.Fprintf(w.Calls, "a%v %v", i, m.Type.In(i).String())
	}
	fmt.Fprintf(w.Calls, ") {\n}\n\n")
	fmt.Fprintf(w.Calls, "func (s *Server%v) RPC%v(", w.Iface, m.Name)
	fmt.Fprintf(w.Calls, "a *Args, r *Results) os.Error {\n}\n\n")
}

/*
func buildMethod(iface string,n int, gf *GoFile,m reflect.Method) {
	fmt.Fprintf(f,"func (st *"+iface+"Stub) "+m.Name+"(")
	nin:=m.Type.NumIn()
	for i:=0;i<nin;i++ {
		if(i>0) {
			fmt.Fprintf(f,",")
		}
		fmt.Fprintf(f,"arg%v %v",i,m.Type.In(i).String())
	}
	fmt.Fprintf(f,") ")
	nout:=m.Type.NumOut()
	if(nout==1) {
		fmt.Fprintf(f,"%v ",m.Type.Out(0).String())
	} else if(nout>1) {
		fmt.Fprintf(f,"(")
		for i:=0;i<nout;i++ {
			if(i>0) {
				fmt.Fprintf(f,",")
			}
			fmt.Fprintf(f,"r%v %v",i,m.Type.Out(i).String())
		}
		fmt.Fprintf(f,")")
	}
	fmt.Fprintf(f,"{\n")
	fmt.Fprintf(f,"\tr,err:=st.invoke(%v",(n+1))
	for i:=0;i<nin;i++ {
		fmt.Fprintf(f,",arg%v",i)
	}
	fmt.Fprintf(f,")\n")
	if(nout==1) {
		fmt.Fprintf(f,"\treturn r[0]\n")
	} else if(nout>1) {	
		for i:=0;i<nout;i++ {
			fmt.Fprintf(f,"\tr%v=r[%v]\n",i,i)
		}
		fmt.Fprintf(f,"\treturn\n")
	}
	fmt.Fprintf(f,"}\n\n")
}

func isInOut(t reflect.Type) bool {
	switch t.Kind() {
		case reflect.Ptr:
			return true
		case reflect.Slice:
			return true
	}
	return false
}*/


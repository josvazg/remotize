// Copyright 2011 Jose Luis Vázquez González josvazg@gmail.com
// Use of this source code is governed by a BSD-style

// remotize package wraps rpc calls so you don't have to rewrite an interface by
// hand in order to use it remotely. 
package tool

import (
	"bytes"
	"exec"
	"fmt"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"os"
	"reflect"
	"github.com/josvazg/remotize"
	"sort"
	"strconv"
	"strings"
)

const RemotizePkg = "github.com/josvazg/remotize"

// remotizer code head and tail & marker
const (
	remotizerHead = `// Autogenerated Remotizer [DO NOT EDIT!]
package main
`
	remotizerTail = `func main() {
	for _,r := range toremotize {
		if e:=tool.Remotize(r); e!=nil {
			panic(e)
		}
	}
}`
)

// The General Spec for a Remotization
type Spec struct {
	packname    string
	isInterface bool
	t           reflect.Type
	imports     map[string]string
	hdr         *bytes.Buffer
	def         *bytes.Buffer
	src         *bytes.Buffer
}

// Remotize remotizes a type, interface or source code specified interface
func Remotize(i interface{}) os.Error {
	var t reflect.Type
	if _, ok := i.(reflect.Type); ok {
		t = i.(reflect.Type)
	} else {
		t = reflect.TypeOf(i)
	}
	if t.Kind() == reflect.Interface {
		return genWrapper(t.Name(), Type2Spec(true, t))
	} else if _, ok := i.(*Spec); ok {
		return genWrapper(t.Name(), i.(*Spec))
	} else if t.NumMethod() > 0 {
		st := t
		for ; st.Kind() == reflect.Ptr; st = st.Elem() {
		}
		return genWrapper(st.Name(), Type2Spec(false, t))
	}
	if t.Kind() == reflect.Ptr {
		return Remotize(t.Elem())
	}
	return os.NewError(fmt.Sprintf("Can't remotize %v!", i))
}

// NewSpec will create an Spec to be remotized
func NewSpec(packname string, isInterface bool, i interface{}) *Spec {
	t := reflect.TypeOf(i)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	return &Spec{packname, isInterface, t, make(map[string]string),
		bytes.NewBufferString(""), bytes.NewBufferString(""), bytes.NewBufferString("")}
}

// Type2Spec Turns a type into a Spec to be remotized
func Type2Spec(isInterface bool, t reflect.Type) *Spec {
	return &Spec{t.PkgPath(), isInterface, t, make(map[string]string),
		bytes.NewBufferString(""), bytes.NewBufferString(""), bytes.NewBufferString("")}
}

// genWrapper generates the wrapper file for a remotized object
func genWrapper(name string, spec *Spec) os.Error {
	f, e := os.Create("remotized" + name + ".go")
	if e != nil {
		return e
	}
	defer f.Close()
	spec.buildInterfaceDef(name)
	spec.buildHeader()
	spec.buildBody(name)
	def:=""
	if !spec.isInterface {
		def=spec.def.String()
	}
 	fmt.Fprintf(f, "%s%s%s", spec.hdr.String(),def,spec.src.String())
	return nil
}

// buildInterfaceDef builds the interface definition and fills the imports field
func (s *Spec) buildInterfaceDef(name string) {
	ifacename := name
	if !s.isInterface {
		ifacename += remotize.Suffix(name)
	}
	fmt.Fprintf(s.def, "type %s interface", ifacename)
	if s.t.NumMethod() > 0 {
		fmt.Fprintf(s.def, " {")
		for i := 0; i < s.t.NumMethod(); i++ {
			m := s.t.Method(i)
			if isExported(m.Name) {
				fmt.Fprintf(s.def, "\n    ")
				s.funcsource(s.def, s.t, &m)
			}
		}
		fmt.Fprintf(s.def, "\n}\n\n")
	}
}

// funcsource will generate the source code for a function declaration (no body)
func (s *Spec) funcsource(w io.Writer, t reflect.Type, m *reflect.Method) {
	start := 0
	if t.Kind() == reflect.Interface {
		fmt.Fprintf(w, m.Name+"(")
	} else if m != nil && m.Name != "" {
		start++
		fmt.Fprintf(w, m.Name+"(")
	} else {
		fmt.Fprintf(w, "func (")
	}
	if m != nil {
		t = m.Type
	}
	for i := start; i < t.NumIn(); i++ {
		s.typesource(w, t.In(i))
		if (i + 1) != t.NumIn() {
			fmt.Fprintf(w, ", ")
		}
	}
	fmt.Fprintf(w, ") ")
	if t.NumOut() > 1 {
		fmt.Fprintf(w, "(")
	}
	for i := 0; i < t.NumOut(); i++ {
		s.typesource(w, t.Out(i))
		if (i + 1) != t.NumOut() {
			fmt.Fprintf(w, ", ")
		}
	}
	if t.NumOut() > 1 {
		fmt.Fprintf(w, ")")
	}
}

// typesource will generate the source code for a type
func (s *Spec) typesource(w io.Writer, t reflect.Type) {
	switch t.Kind() {
	case reflect.Array:
		fmt.Fprintf(w, "["+strconv.Itoa(t.Len())+"]")
		s.typesource(w, t.Elem())
	case reflect.Chan:
		fmt.Fprintf(w, "chan ")
		s.typesource(w, t.Elem())
	case reflect.Func:
		s.funcsource(w, t, nil)
	case reflect.Map:
		fmt.Fprintf(w, "map[")
		s.typesource(w, t.Key())
		fmt.Fprintf(w, "]")
		s.typesource(w, t.Elem())
	case reflect.Ptr:
		fmt.Fprintf(w, "*")
		s.typesource(w, t.Elem())
	case reflect.Slice:
		fmt.Fprintf(w, "[]")
		s.typesource(w, t.Elem())
	case reflect.String:
		fmt.Fprintf(w, "string")
	default:
		s.pack(t)
		name:=t.String()
		if t.PkgPath()==s.packname {
			name=t.Name()
		}
		fmt.Fprintf(w, name)
		return
	}
}

// pack will record the type's package as an import
func (s *Spec) pack(t reflect.Type) {
	packpath := t.PkgPath()
	if packpath != "" {
		alias := t.String()[0 : len(t.String())-len(t.Name())-1]
		s.imports[alias] = packpath
	}
}

// buildHeader will build the header for the source file including package and imports
func (s *Spec) buildHeader() {
	s.hdr = bytes.NewBufferString("// Autogenerated by josvazg/remotize/tool - no need to edit!\n\n")
	fmt.Fprintf(s.hdr, "package %v\n\n", path2pack(s.packname))
	if s.imports == nil {
		s.imports = make(map[string]string)
	}
	s.imports["rpc"] = "rpc"
	s.imports["os"] = "os"
	if s.packname != RemotizePkg {
		s.imports[RemotizePkg] = RemotizePkg
	}
	names := make([]string, 0)
	for _, name := range s.imports {
		names = append(names, name)
	}
	writeImports(s.hdr, names, s.imports, s.packname)
}

// buildBody builds the wrapper body source code
func (s *Spec) buildBody(ifacename string) {
	fmt.Fprintf(s.src, "// Autoregistry\n")
	fmt.Fprintf(s.src, "func init() {\n")
	fmt.Fprintf(s.src, "    remotize.Register(Remote%s{},\n", ifacename)
	fmt.Fprintf(s.src, "        func(cli *rpc.Client) interface{} "+
		"{\n\t\t\treturn NewRemote%s(cli)\n\t\t},\n", ifacename)
	fmt.Fprintf(s.src, "        %sService{},\n", ifacename)
	fmt.Fprintf(s.src, "        func(srv *rpc.Server, i interface{}) "+
		" interface{} {\n\t\t\treturn New%sService(srv,i.(%s))\n\t\t},\n",
		ifacename, ifacename)
	fmt.Fprintf(s.src, "    )\n")
	fmt.Fprintf(s.src, "}\n\n")
	s.remoteInit(ifacename)
	s.localInit(ifacename)
	for i := 0; i < s.t.NumMethod(); i++ {
		s.wrapMethod(ifacename, s.t.Method(i))
	}
}

// remoteInit prepares the service header
func (s *Spec) remoteInit(ifacename string) {
	fmt.Fprintf(s.src, "// Rpc service wrapper for %s\n", ifacename)
	fmt.Fprintf(s.src, "type %sService struct {\n", ifacename)
	fmt.Fprintf(s.src, "    srv %s\n", ifacename)
	fmt.Fprintf(s.src, "}\n\n")
	fmt.Fprintf(s.src, "// Direct %sService constructor\n", ifacename)
	fmt.Fprintf(s.src, "func New%sService(srv *rpc.Server, impl %s) *%sService {\n",
		ifacename, ifacename, ifacename)
	fmt.Fprintf(s.src, "    r:=&%sService{impl}\n", ifacename)
	fmt.Fprintf(s.src, "    srv.Register(r)\n")
	fmt.Fprintf(s.src, "    return r\n")
	fmt.Fprintf(s.src, "}\n\n")
}

// localInit prepares the client header
func (s *Spec) localInit(ifacename string) {
	fmt.Fprintf(s.src, "// Rpc client for %s\n", ifacename)
	fmt.Fprintf(s.src, "type Remote%s struct {\n", ifacename)
	fmt.Fprintf(s.src, "    cli *rpc.Client\n")
	fmt.Fprintf(s.src, "}\n\n")
	fmt.Fprintf(s.src, "// Direct Remote%s constructor\n", ifacename)
	fmt.Fprintf(s.src, "func NewRemote%s(cli *rpc.Client) *Remote%s {\n",
		ifacename, ifacename)
	fmt.Fprintf(s.src, "    return &Remote%s{cli}\n", ifacename)
	fmt.Fprintf(s.src, "}\n\n")
}

// wrapMethod generates the wrappers for one method
func (s *Spec) wrapMethod(ifacename string, m reflect.Method) {
	fmt.Fprintf(s.src, "// wrapper for: %s\n\n", m.Name)
	args := make([]reflect.Type, 0)
	for i:=0;i<m.Type.NumIn();i++ {
		args=append(args,m.Type.In(i))
	}
	s.generateStructWrapper(args, "Args", m.Name)
	results, inouts := s.prepareInOuts(m.Type)
	s.generateStructWrapper(results, "Reply", m.Name)
	s.generateServerRPCWrapper(m, ifacename, inouts)
	s.generateClientRPCWrapper(m, ifacename, inouts)
	fmt.Fprintf(s.src, "\n")
}

// generateStructWrapper generates a argument or result struct
func (s *Spec) generateStructWrapper(pars []reflect.Type, structname, name string) {
	fmt.Fprintf(s.src, "type %s_%s struct {\n", structname, name)
	for i,par := range pars {
		fmt.Fprintf(s.src, "\tArg%d ", i)
		s.typesource(s.src,par)
		fmt.Fprintf(s.src, "\n")
	}
	fmt.Fprintf(s.src, "}\n\n")
}

// prepareInOuts detects how many pointers in the args must be returned as results (in & outs)
func (s *Spec) prepareInOuts(ft reflect.Type) ([]reflect.Type, []int) {
	results := make([]reflect.Type, 0)
	inouts := make([]int, 0)
	for i := 0; i < ft.NumIn(); i++ {
		if ft.In(i).Kind()==reflect.Ptr {
			results=append(results,ft.In(i))
			inouts=append(inouts,i)
		}
	}
	for i:=0; i<ft.NumOut();i++ {
		results=append(results,ft.Out(i))
	}
	return results, inouts
}

// function that is exposed to an RPC API, but calls simple "Server_" one
func (s *Spec) generateServerRPCWrapper(m reflect.Method, ifacename string, inouts []int) {
	name:=m.Name
	ins:=m.Type.NumIn()
	outs:=m.Type.NumOut()
	fmt.Fprintf(s.src, "func (r *%sService) %s(args *Args_%s, "+
		"reply *Reply_%s) os.Error {\n", ifacename, name, name, name)
	fmt.Fprintf(s.src, "\t")
	replies := outs - len(inouts)
	for i := 0; i < replies; i++ {
		fmt.Fprintf(s.src, "reply.Arg%d", i)
		if i != replies-1 {
			fmt.Fprintf(s.src, ", ")
		}
	}
	if replies > 0 {
		fmt.Fprintf(s.src, " = ")
	}
	fmt.Fprintf(s.src, "r.srv.%s(", name)
	for i := 0; i < ins; i++ {
		fmt.Fprintf(s.src, "args.Arg%d", i)
		if i != ins-1 {
			fmt.Fprintf(s.src, ", ")
		}
	}
	fmt.Fprintf(s.src, ")\n")
	for i := replies; i < outs; i++ {
		fmt.Fprintf(s.src, "\treply.Arg%d=args.Arg%d\n", i, inouts[i-replies])
	}
	fmt.Fprintf(s.src, "\treturn nil\n}\n\n")
}

// generateClientRPCWrapper generates the client side wrapper
func (s *Spec) generateClientRPCWrapper(m reflect.Method, ifacename string, inouts []int) {
	name:=m.Name
	ins:=m.Type.NumIn()
	outs:=m.Type.NumOut()
	fmt.Fprintf(s.src, "func (l *Remote%s) %s(", ifacename, name)
	s.printFuncFieldListUsingArgs(m.Type)
	fmt.Fprintf(s.src, ") ")
	s.printFuncResultList(m.Type)
	fmt.Fprintf(s.src, "{\n")
	fmt.Fprintf(s.src, "\tvar args Args_%s\n", name)
	fmt.Fprintf(s.src, "\tvar reply Reply_%s\n", name)
	for i := 0; i < ins; i++ {
		fmt.Fprintf(s.src, "\targs.Arg%d = Arg%d\n", i, i)
	}
	fmt.Fprintf(s.src, "\terr := l.cli.Call(\"%sService.%s\", &args, &reply)\n",
		ifacename, name)
	fmt.Fprintf(s.src, "\tif err != nil {\n")
	fmt.Fprintf(s.src, "\t\tpanic(err.String())\n\t}\n")

	replies := outs - len(inouts)
	for i := replies; i < outs; i++ {
		fmt.Fprintf(s.src, "\t*reply.Arg%d=*args.Arg%d\n", i, inouts[i-replies])
	}
	fmt.Fprintf(s.src, "\treturn ")
	for i := 0; i < outs; i++ {
		fmt.Fprintf(s.src, "reply.Arg%d", i)
		if i != outs-1 {
			fmt.Fprintf(s.src, ", ")
		}
	}
	fmt.Fprintf(s.src, "\n}\n\n")
}

// printFuncFieldListUsingArgs generates the func field list with argX names
func (s *Spec) printFuncFieldListUsingArgs(t reflect.Type) {
	if t.IsVariadic() {
		panic(fmt.Sprintf("Variadic argument lists as in '%v' are not supported!",t))
	}
	for i:=0;i<t.NumIn();i++ {
		// names
		fmt.Fprintf(s.src,"Arg%d ",i)
		s.typesource(s.src, t.In(i))
		// ,
		if i != t.NumIn()-1 {
			fmt.Fprintf(s.src, ", ")
		}
	}
}

// printFuncResultList generates the func field list with type names
func (s *Spec) printFuncResultList(t reflect.Type) {
	outs:=t.NumOut()
	if outs>1 {
		fmt.Fprintf(s.src, "(")
	}
	for i:=0;i<outs;i++ {
		// names
		s.typesource(s.src,t.Out(i))
		// ,
		if i != outs-1 {
			fmt.Fprintf(s.src, ", ")
		}
	}
	if outs>1 {
		fmt.Fprintf(s.src, ") ")
	} else {
		fmt.Fprintf(s.src, " ")
	}
}

// suppress will remove the ocurrences of sups strings from s 
// and return the result
func suppress(s string, sups ...string) string {
	for _, sup := range sups {
		s = strings.Replace(s, sup, "", -1)
	}
	return s
}

// generateRemotizerCode returns the remotizer source code for a given set of Detected remotizables
func generateRemotizerCode(d *Detected) string {
	src := bytes.NewBuffer(make([]byte, 0))
	fmt.Fprintf(src, remotizerHead)
	genImports(src, d)
	genTypeDefs(src, d)
	fmt.Fprintf(src, "var toremotize = []interface{}{")
	for name, dcl := range d.RDecls {
		fmt.Fprintf(src, "\n\tNewSpec(\"%v\",", d.packname)
		fmt.Fprintf(src, "%v,", dcl.isInterface)
		fmt.Fprintf(src, "new(%v))", ifacename(name))
	}
	for _, s := range d.RTypes {
		fmt.Fprintf(src, "\n\tnew(%v),", s)
	}
	fmt.Fprintf(src, "\n}\n\n")
	fmt.Fprintf(src, remotizerTail)
	return src.String()
}

// genImports adds imports to the remotizer source code from types
func genImports(src io.Writer, d *Detected) {
	imports := []string{"github.com/josvazg/remotize/tool"}
	for _, typename := range d.RTypes {
		packname := strings.SplitN(typename, ".", 2)[0]
		imports = addImport(imports, packname)
	}
	for _, decl := range d.RDecls {
		for packname, _ := range decl.imports {
			imports = addImport(imports, packname)
		}
	}
	writeImports(src, imports, d.aliases, "")
}

func addImport(imports []string, packname string) []string {
	for _, imp := range imports {
		if packname == imp {
			return imports
		}
	}
	return append(imports, packname)
}

// genTypeDefs adds types and interface source code definitions from this packages to the remotizer
func genTypeDefs(src io.Writer, d *Detected) {
	for _, decl := range d.RDecls {
		if decl.Src != nil {
			fmt.Fprintf(src, "\n%s\n", decl.Src)
		}
	}
}

func writeImports(w io.Writer, imports []string, aliases map[string]string, skip string) {
	sort.Strings(imports)
	fmt.Fprintf(w, "import (\n")
	for _, s := range imports {
		v := aliases[s]
		if v == skip || v == "" {
			continue
		}
		if s == v {
			fmt.Fprintf(w, "\t\"%s\"\n", s)
		} else {
			fmt.Fprintf(w, "\t%s \"%s\"\n", s, v)
		}
	}
	fmt.Fprintf(w, ")\n\n")
}

// writeAndFormatSource writes the go source to a file properly formatted
func writeAndFormatSource(filename, source string) os.Error {
	fset := token.NewFileSet()
	f, e := parser.ParseFile(fset, filename+".go", source, parser.ParseComments)
	if e != nil {
		fmt.Println(source)
		return e
	}
	fos, e := os.Create(filename + ".go")
	if e != nil {
		return e
	}
	pcfg := &printer.Config{printer.TabIndent, 2}
	pcfg.Fprint(fos, fset, f)
	fos.Close()
	_, e = os.Stat(filename + ".go")
	return e
}

// build generates a program to remotize the detected interfaces
func buildRemotizer(d *Detected) os.Error {
	src := generateRemotizerCode(d)
	fmt.Println("buildRemotizer:\n", src)
	filename := "_remotizer"
	if e := writeAndFormatSource(filename, src); e != nil {
		return e
	}
	if o, e := RunCmd(Gocompile(), "-I", "_test", filename+".go"); e != nil {
		fmt.Fprintf(os.Stderr, string(o)+"\n")
		return e
	}
	if o, e := RunCmd(Golink(), "-L", "_test", "-o", filename,
		filename+"."+Goext()); e != nil {
		fmt.Fprintf(os.Stderr, string(o)+"\n")
		return e
	}
	if o, e := RunCmd("./" + filename); e != nil {
		fmt.Fprintf(os.Stderr, string(o)+"\n")
		return e
	}
	return nil
}
/*
func save(filename, contents string) {
	f, e := os.Create(filename)
	if e != nil {
		panic(e)
	}
	f.Write(([]byte)(contents))
	f.Close()
}
*/
// runs a command
func RunCmd(cmdargs ...string) ([]byte, os.Error) {
	fmt.Println(cmdargs)
	return exec.Command(cmdargs[0], cmdargs[1:]...).CombinedOutput()
}

// dictionary cache
var dict map[string]string

// go tool execution string
func Goexec(tool string) string {
	if dict == nil {
		dict = make(map[string]string)
		dict["386"] = "8"
		dict["amd64"] = "6"
		dict["arm"] = "5"
		dict["compiler"] = "g"
		dict["linker"] = "l"
	}
	return dict[os.Getenv("GOARCH")] + dict[tool]
}

// Go compiler
func Gocompile() string {
	return Goexec("compiler")
}

// Go linker
func Golink() string {
	return Goexec("linker")
}

// Go architecture extension
func Goext() string {
	return Goexec("")
}

